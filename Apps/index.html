<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1c1f24">
    <meta name="googlebot" content="index, follow, snippet">
    <meta name="robots" content="index, follow">

    <title>Apps Hub</title> <!-- Corrected title -->

    <!-- Favicon -->
    <!-- Path is correct: ../ goes up one level from Apps/ to the root -->
    <link rel="icon" href="../2cJw7a9.png" type="image/x-icon">
    <link rel="shortcut icon" href="../2cJw7a9.png" type="image/x-icon">

    <!-- Google Fonts: Lato -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Link to the shared global CSS -->
    <!-- Path is correct: ../ goes up one level from Apps/ to the root -->
    <link rel="stylesheet" href="../globalStyles.css">

    <!-- Global Scripts (Order matters: particles.js first, then settings) -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <!-- globalSettings.js needs to contain the IIFE block for settings state management -->
    <!-- Path is correct: ../ goes up one level from Apps/ to the root -->
    <script src="../globalSettings.js"></script>

    <!-- AdSense (Keep) -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4207227785539100"
         crossorigin="anonymous"></script>

    <!-- Keep ONLY Apps-specific styles here and add settings styles -->
    <style>
        /* --- Settings Side Menu Styles (Copied from index.html context) --- */
        /* Scrollbar styling for settings panel */
        #settings.content-section::-webkit-scrollbar {
            width: 10px;
        }
        #settings.content-section::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        #settings.content-section::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        #settings.content-section::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        #settings.content-section {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) rgba(255, 255, 255, 0.05);
        }

        /* Fix for color button layout */
        .settings-group .setting-item .color-button-list {
          display: flex;
          flex-wrap: wrap; /* Allow buttons to wrap to the next line */
          gap: 5px; /* Space between buttons */
          justify-content: flex-start; /* Align buttons to the start */
          align-items: center;
        }

        .settings-color-button {
          width: 28px; /* Slightly larger for better click area */
          height: 28px; /* Keep it square */
          border-radius: 50%; /* Make them round */
          border: 2px solid transparent; /* Default border */
          cursor: pointer;
          padding: 0;
          flex-shrink: 0; /* Prevent shrinking */
          transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Smooth transition */
        }

        .settings-color-button.active {
          border-color: var(--cursor-hover-border-color, #007bff); /* Indicate active state */
          box-shadow: 0 0 8px rgba(0, 123, 255, 0.6); /* Optional glow */
        }
         .settings-color-button:hover:not(.active) {
             border-color: rgba(255, 255, 255, 0.3); /* Subtle hover effect */
         }

        section#settings.content-section {
            position: fixed;
            top: 0;
            right: -350px; /* Off-screen initially */
            visibility: hidden;
            width: 100%;
            max-width: 340px;
            height: 100vh;
            overflow-y: auto;
            background-color: var(--overlay-background, rgba(0, 0, 0, 0.95));
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            z-index: 100;
            transition: right 0.3s ease-out, visibility 0s linear 0.3s;

            padding-top: 80px;
            padding-bottom: 40px;
            padding-left: 20px;
            padding-right: 20px;
            box-sizing: border-box;
             display: block !important; /* Override display:none from potential showSection logic */
        }

        section#settings.content-section.is-visible {
            right: 0;
            visibility: visible;
            transition: right 0.3s ease-out, visibility 0s linear 0s;
        }

        /* Settings Overlay */
        #settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--overlay-background, rgba(0, 0, 0, 0.5));
            z-index: 99;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none; /* Allows clicks to pass through when hidden */
        }

        #settings-overlay.is-visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto; /* Allows clicks to close the menu */
        }

        /* Style to prevent body scrolling when settings are open */
        body.settings-open {
            overflow: hidden;
        }
        /* Optional: effect on main content when settings menu is open */
        body.settings-open main.hub-container {
             filter: blur(10px);
             transition: filter 0.3s ease;
             pointer-events: none; /* Disable interaction with content behind menu */
        }

         /* Ensure buttons and selects inside settings have dark theme styles */
         #settings.content-section button,
         #settings.content-section select {
             background-color: var(--button-background-dark, #333);
             color: var(--button-text-color-dark, #eee);
             border: 1px solid var(--button-border-color-dark, #555);
             border-radius: 4px;
             padding: 8px 12px;
             font-family: inherit;
             font-size: 1rem;
             cursor: pointer;
             transition: background-color 0.2s ease, border-color 0.2s ease;
         }

          #settings.content-section button:hover,
          #settings.content-section select:hover {
              background-color: var(--button-background-hover-dark, #444);
              border-color: var(--button-border-color-hover-dark, #777);
          }
           #settings.content-section button:active {
               background-color: var(--button-background-active-dark, #222);
               border-color: var(--button-border-color-active-dark, #666);
           }

           #settings.content-section button:disabled,
           #settings.content-section select:disabled {
               opacity: 0.5;
               cursor: not-allowed;
           }

         /* --- Sneak Mode Select Specific Styles --- */
         #sneak-mode-select {
            /* Override some general button/select styles if needed, or just inherit */
            /* background-color, color, border inherited from above */
            padding: 6px 10px; /* Adjust padding specifically for the select */
            /* Add some default styles to remove browser defaults */
            -webkit-appearance: none; /* Remove default browser styling in Webkit browsers */
            -moz-appearance: none;    /* Remove default browser styling in Firefox */
            appearance: none;         /* Remove default browser styling */
            /* Add a custom arrow for appearance */
            /* Using an inline SVG with light grey color (#eeeeee) */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23eeeeee%22%20d%3D%22M287%2C114.7L159.3%2C242.5c-5.8%2C5.8-15.2%2C5.8-21%2C0L5.4%2C114.7c-5.8-5.8-5.8-15.2%2C0-21l19.8-19.8 c5.8-5.8%2C15.2-5.8%2C21%2C0l109.5%2C109.5l109.5-109.5c5.8-5.8%2C15.2-5.8%2C21%2C0l19.8%2C19.8C292.8%2C99.5%2C292.8%2C108.9%2C287%2C114.7z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 12px auto;
            padding-right: 30px; /* Make space for the custom arrow */
         }

         /* Style for options within the dropdown (less reliable cross-browser, may need system overrides) */
         #sneak-mode-select option {
           background-color: var(--background-color-dark, #2a2a2a); /* Dark background for options */
           color: var(--text-color-light, #eeeeee); /* Light text for options */
         }


        /* Responsive adjustments for the settings menu */
        @media (max-width: 768px) {
             section#settings.content-section {
                 max-width: 280px;
                 right: -290px;
                 padding-top: 80px;
            }
            section#settings.content-section.is-visible {
                 right: 0;
            }
        }

        @media (max-width: 480px) {
             section#settings.content-section {
                 max-width: 90%;
                 right: -100%;
                 padding-top: 80px;
            }
            section#settings.content-section.is-visible {
                 right: 0;
            }
        }
        /* --- End Settings Side Menu Styles --- */

        /* --- Custom Cursor Styles --- */
        #custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 24px; /* Increased Size */
            height: 24px; /* Increased Size */
            border-radius: 50%;
            border: 2px solid var(--cursor-border-color, rgba(255, 255, 255, 0.5));
            pointer-events: none;
            z-index: 10000;
            opacity: 0; /* Hidden by default, shown by body class */
            /* Base transition: opacity animates, transform (position) is instant */
            transition: opacity 0.3s ease, transform 0s linear;
            /* Set initial transform to handle CSS variables */
            transform: translate(var(--mouse-x, 0), var(--mouse-y, 0)); /* Default 0 if vars not set yet */
        }

        /* Only show the custom cursor if enabled by setting (via body class) */
        body.custom-cursor-enabled #custom-cursor {
             opacity: 1; /* Visible when enabled */
        }

        /* Hide the default cursor when the custom cursor is enabled */
        body.custom-cursor-enabled {
             cursor: none !important;
        }

        /* Style for interactive elements, only applies if cursor is enabled */
        body.custom-cursor-enabled #custom-cursor.on-interactive {
            /* Keep translate from base, just add scale and border transition */
             transform: translate(var(--mouse-x), var(--mouse-y)) scale(1.5); /* Example hover scale */
             border-color: var(--cursor-hover-border-color, #007bff); /* Use variable for hover color */
             /* Add transitions for the properties that change specifically on hover (scale, border-color) */
             transition: opacity 0.3s ease, transform 0.1s ease, border-color 0.2s ease; /* Scale transition 0.1s */
        }
         body.custom-cursor-enabled #custom-cursor.clicked {
            /* Keep translate from base, just add scale transition */
            transform: translate(var(--mouse-x), var(--mouse-y)) scale(0.8); /* Example click scale */
             /* Add transitions for the properties that change specifically on click (scale) */
           transition: opacity 0.3s ease, transform 0.1s ease; /* Scale transition 0.1s */
         }
         /* When not interactive or clicked, the base styles apply, which should now have transform: 0s linear */
        /* --- END Custom Cursor Styles --- */


        /* --- Unfocused Overlay Styles --- */
        #unfocused-overlay {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           /* Use background-image set by JS based on selection */
           background-size: cover; /* This makes the image cover the entire area */
           background-position: center; /* This centers the image */
           background-repeat: no-repeat; /* Prevent the image from tiling */

           /* Fallback background color if the image doesn't load */
           background-color: #f8f8f8;

           display: none; /* Hidden by default, shown by JS */
           /* INCREASED Z-INDEX to be above the header (101) and settings overlay (99) */
           z-index: 102;

           box-sizing: border-box;
           pointer-events: none; /* Disable interaction with content below */
        }


         /* Optional: Add body class for unfocused state to disable interaction on main content */
         /* blur effect is handled by the settings-open class on main.hub-container now */
         /* body.unfocused main.hub-container { */
         /*     filter: blur(5px); */
         /*     transition: filter 0.3s ease; */
         /*     pointer-events: none; */ /* Ensure content is not interactive */
         /* } */


        /* Base Body Styles for Apps Page Layout */
        /* globalStyles.css handles background, color, cursor, overflow-x */
        body {
            min-height: 100vh;
            overflow-y: auto;
            display: block;
            max-width: none;
            padding: 0;
            margin: 0;
             /* Ensure body has position: relative or similar for proper z-index stacking */
            position: relative;
            z-index: 0; /* Lower than particles */
        }
        /* Particles div needs to be between body and content/header */
         #particles-js {
             position: fixed;
             width: 100%;
             height: 100%;
             top: 0;
             left: 0;
             z-index: -1; /* Ensure particles are behind everything */
             background-color: var(--background-color-dark, #2a2a2a); /* Use variable or fallback */
             /* Ensure particles div doesn't cause layout issues */
             pointer-events: none;
         }


        /* Header styles - Ensure consistency or use global */
        /* Assuming globalStyles.css handles main header layout */
        header {
            position: fixed; /* Keep header fixed */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 101; /* Higher than settings menu and overlay */
            background-color: var(--header-background-dark, rgba(0, 0, 0, 0.8)); /* Use variable or fallback */
            /* Add backdrop blur if desired */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            /* Ensure padding/height fits content */
            box-sizing: border-box;
            padding: 10px 40px; /* Match content padding */
            /* Transition for background color on scroll if needed, but fixed headers often don't change background */
        }
        /* Ensure header content container uses flex from globalStyles */
         header .header-container {
             display: flex !important;
             justify-content: flex-start !important; /* Align items to the left */
             align-items: center !important;
             gap: 15px !important; /* Space between logo and nav */
             width: 100%;
             max-width: var(--content-max-width, 1600px); /* Match main content max-width */
             margin: 0 auto; /* Center the header content */
         }
         /* Ensure header nav ul uses flex from globalStyles */
         header nav ul {
             display: flex !important;
             align-items: center !important;
             list-style: none !important;
             padding: 0 !important;
             margin: 0 !important;
             gap: 15px !important; /* Space between nav items */
         }


        /* Main Content Area - Needs top padding to not be hidden by fixed header */
        main.hub-container {
            /* globalStyles.css provides base .content-section padding. Match or override. */
            padding-top: 100px; /* Space for the fixed header */
            padding-bottom: 20px;
            padding-left: 40px;
            padding-right: 40px;
            width: 100%;
            max-width: var(--content-max-width, 1600px);
            margin: 0 auto;
            position: relative;
            z-index: 1; /* Ensure content is above particles */
            display: block;
             transition: filter 0.3s ease; /* For settings-open blur */
             box-sizing: border-box;
        }


        /* Search and Controls section */
        .hub-controls {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 30px;
          padding: 15px;
          background: rgba(30, 30, 30, 0.5);
          border-radius: 8px;
          backdrop-filter: blur(5px);
          -webkit-backdrop-filter: blur(5px);
          gap: 20px;
          flex-wrap: wrap;
           /* Entrance Animation */
          opacity: 0;
          transform: translateY(20px);
          animation: controlsEntrance 0.6s ease-out forwards 0.7s;
           z-index: 1; /* Ensure controls are above particle interactivity area */
        }
         @keyframes controlsEntrance {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
         }

        .search-wrapper {
          display: flex;
          align-items: center;
          background: rgba(255, 255, 255, 0.1);
          border-radius: 20px;
          padding: 0px 5px 0px 15px;
          flex-grow: 1;
          max-width: 500px;
          transition: background 0.3s ease, box-shadow 0.3s ease;
        }
        .search-wrapper:focus-within {
          background: rgba(255, 255, 255, 0.2);
          box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        #myInput {
          flex-grow: 1;
          padding: 10px;
          border: none;
          background: transparent;
          color: #fff;
          font-size: 1rem;
          outline: none;
           /* cursor: none !important; /* Ensure custom cursor - handled by JS now */
        }
         body.custom-cursor-enabled #myInput {
             cursor: none !important;
         }

        #myInput::placeholder {
          color: #aaa;
        }
        .search-icon-btn {
          background: transparent;
          border: none;
          color: #ddd;
          font-size: 1.1rem;
          padding: 10px;
          cursor: pointer;
          transition: color 0.3s ease;
        }
        .search-icon-btn:hover {
          color: #fff;
        }
        .toggle-categories-btn {
          background: linear-gradient(90deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.15));
          color: #e0e0e0;
          border: 1px solid rgba(255, 255, 255, 0.2);
          padding: 10px 20px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 0.9rem;
          font-weight: bold;
          transition: all 0.3s ease;
          backdrop-filter: blur(3px);
          -webkit-backdrop-filter: blur(3px);
        }
        .toggle-categories-btn:hover {
          background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.2));
          box-shadow: 0 0 8px rgba(255, 255, 255, 0.15);
          transform: translateY(-1px);
          color: #fff;
        }


        /* Container for Categories Entrance Animation */
        .categories-wrapper {
            opacity: 0;
            transform: translateY(20px);
            animation: categoriesEntrance 0.6s ease-out forwards 0.9s;
             z-index: 1; /* Ensure wrapper is above particle interactivity area */
             position: relative; /* Needed for z-index to work */
        }
         @keyframes categoriesEntrance {
             from { opacity: 0; transform: translateY(20px); }
             to { opacity: 1; transform: translateY(0); }
         }


        /* Category Sections Layout */
        .game-category { /* Keeping game-category class name for consistency */
            display: flex;
            flex-direction: column;
            margin-bottom: 30px;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .category-header h6 {
            font-size: 1.8rem;
            background: linear-gradient(45deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6), 0 0 25px rgba(255, 255, 255, 0.5);
            display: inline-flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
             /* Entrance Animation */
             opacity: 0;
             transform: translateX(-20px);
             animation: categoryHeaderEntrance 0.5s ease-out forwards;
             animation-delay: 1.2s;
        }
         @keyframes categoryHeaderEntrance {
             from { opacity: 0; transform: translateX(-20px); }
             to { opacity: 1; transform: translateX(0); }
         }

        .category-header h6 i {
            font-size: 0.9em;
            background: linear-gradient(45deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }


        /* Scroll Arrows for Categories */
        .scroll-arrows {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
            align-items: center;
        }
        .scroll-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transform: scale(1) translateZ(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            width: 35px;
            height: 35px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            border-radius: 50%;
            will-change: opacity, transform;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }

        .scroll-arrow.hidden {
            opacity: 0;
            transform: scale(0.8) translateZ(0);
            pointer-events: none;
        }

        .scroll-arrow:hover {
            transform: scale(1.1) translateZ(0);
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
        }

        .scroll-arrow:active {
            transform: scale(0.95) translateZ(0);
            transition: transform 0.1s ease;
        }

        /* Pulse animation for arrows */
        @keyframes arrowPulse {
            0% { transform: scale(1) translateZ(0); }
            50% { transform: scale(1.15) translateZ(0); }
            100% { transform: scale(1) translateZ(0); }
        }
        .scroll-arrow.show-pulse {
            animation: arrowPulse 0.4s ease;
        }


        /* Game Button Containers (Horizontal Scroll & Grid) */
        .btn-container,
        .favorite-container { /* Keep favorite-container for the apps page */
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 10px 5px 20px 5px;
            gap: 20px;
            white-space: nowrap;
            flex-wrap: nowrap;
            scroll-behavior: smooth;
            will-change: scroll-position;
            transform: translateZ(0); /* Force GPU rendering */

            /* Hide scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
         /* Hide scrollbar for Webkit browsers */
        .btn-container::-webkit-scrollbar,
        .favorite-container::-webkit-scrollbar {
            display: none;
        }


        /* Grid container for the "All Games/Apps" section */
        .btn-container-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 20px;
            padding: 10px 0;
             /* Entrance Animation */
            opacity: 0;
            transform: translateY(20px);
            animation: categoriesEntrance 0.6s ease-out forwards 0.9s;
        }


        /* Individual Game/App Button Styling */
        .btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 180px;
            height: 150px;
            background: linear-gradient(135deg, rgba(45, 45, 45, 0.65), rgba(60, 60, 60, 0.75));
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 0;
            overflow: hidden;
            color: #ddd;
            text-decoration: none;
            cursor: pointer;
            position: relative;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            vertical-align: top;
            flex-shrink: 0;
             transform: translateZ(0);

            /* --- Animation Properties --- */
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s ease-out,
                        transform 0.3s ease-out,
                        box-shadow 0.3s ease,
                        border-color 0.3s ease,
                        background 0.3s ease;
            will-change: opacity, transform;
        }

        /* Ensure grid buttons have auto width */
        .btn-container-grid .btn {
            width: auto;
            height: 150px;
        }

        /* Hover state for the button */
        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.25);
            background: linear-gradient(135deg, rgba(55, 55, 55, 0.75), rgba(70, 70, 70, 0.85));
        }

        /* Functional hidden class for search results */
        .btn.hidden {
            display: none !important;
        }

        /* Style for the image - should always be visible */
        .btn .imgg {
            display: block;
            width: 100%;
            flex-grow: 1;
            object-fit: cover;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background-color: #222;
        }

        /* Style for the App/Game Info Bar container */
        .game-info-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 10px;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* --- Hide by default using transform --- */
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            z-index: 2;
             pointer-events: none; /* Allow clicks to pass through to the button below */
        }

        /* Style for the App/Game name text inside the bar */
        .game-info-bar .game-name {
            display: block;
            font-size: 0.95rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            text-align: center;
        }

        /* On button hover, show the info bar */
        .btn:hover .game-info-bar {
            transform: translateY(0);
             pointer-events: none;
        }

        /* Style for the heart icon */
        .btn .heart-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.5);
            background-color: rgba(0, 0, 0, 0.4);
            padding: 4px 5px;
            border-radius: 4px;
            transition: all 0.3s ease;
            z-index: 5;
            cursor: pointer;
            pointer-events: auto; /* Ensure clicks are registered ON THE ICON */
        }
        /* Hover state for the heart icon */
        .btn:hover .heart-icon {
            color: rgba(255, 255, 255, 0.8);
            background-color: rgba(0, 0, 0, 0.6);
        }
        /* State when heart is clicked/favorited */
        .btn .heart-icon.hearted {
            color: #ff6b6b;
            text-shadow: 0 0 8px rgba(255, 107, 107, 0.8);
        }
        .btn .heart-icon.hearted:hover {
             color: #ff4747;
        }


        /* Favorites Section Styling */
        .favorites-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 40px;
            /* display is controlled by JS */
        }

        /* Message for no search results */
        #noResultsMessage {
            text-align: center;
            margin-top: 30px;
            font-size: 1.3em;
            color: #ccc;
             /* Entrance Animation */
            opacity: 0;
            transform: translateY(20px);
            animation: noResultsEntrance 0.5s ease-out forwards;
            animation-delay: 1.5s;
        }
         @keyframes noResultsEntrance {
             from { opacity: 0; transform: translateY(20px); }
             to { opacity: 1; transform: translateY(0); }
         }


        /* Responsive adjustments for Apps layout */
        @media (max-width: 1200px) {
          main.hub-container { padding: 90px 30px 20px 30px; }
          .btn-container-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); }
          .btn { width: 160px; height: 140px; }
          .game-info-bar { height: 35px; font-size: 0.9em; }
          .game-info-bar .game-name { font-size: 0.9em; }
        }

        @media (max-width: 768px) {
           /* Header/Nav styles are in globalStyles.css now */
            header { padding: 10px 15px; } /* Adjust header padding */
            header .header-container { flex-direction: column; gap: 10px; } /* Stack header items */
            header nav ul { flex-direction: column; align-items: flex-start; gap: 8px; } /* Stack nav links */


          main.hub-container {
               padding-top: 140px; /* Adjust for stacked header */
               padding-left: 15px;
               padding-right: 15px;
               padding-bottom: 30px;
          }
           /* Adjust animation delays for smaller screens */
           .hub-controls { animation-delay: 0.8s; }
           .categories-wrapper { animation-delay: 1s; }
           .game-category .category-header h6 { animation-delay: 1.3s; }
           #noResultsMessage { animation-delay: 1.6s; }


           .hub-controls { flex-direction: column; align-items: stretch; padding: 10px; gap: 10px; }
           .search-wrapper { max-width: none; padding: 0px 5px 0px 10px; }
           #myInput { padding: 8px; font-size: 0.9rem; }
           .search-icon-btn { padding: 8px; }

           .category-header h6 { font-size: 1.6rem; gap: 8px;}
           .scroll-arrow { width: 30px; height: 30px; font-size: 0.9rem; }

           .btn-container, .favorite-container { gap: 15px; padding: 8px 5px 15px 5px; }
           .btn-container-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; }

           .btn { width: 140px; height: 130px; }
           .game-info-bar { height: 30px; font-size: 0.85em; }
           .game-info-bar .game-name { font-size: 0.85em; }
           .btn .heart-icon { font-size: 1rem; top: 6px; right: 6px; padding: 3px 4px; }
        }

        @media (max-width: 480px) {
           /* Header/Nav styles are in globalStyles.css now */
           header { padding: 10px; } /* Adjust header padding */
           header .header-container { gap: 8px; }
           header nav ul { gap: 6px; }

          main.hub-container {
            padding-top: 120px; /* Adjust for stacked header */
            padding-left: 10px;
            padding-right: 10px;
            padding-bottom: 20px;
        }
           /* Animation delays remain the same as 768px */

           .category-header h6 { font-size: 1.4rem; gap: 6px; }
           .scroll-arrow { width: 28px; height: 28px; font-size: 0.8rem; }

           .btn-container, .favorite-container { gap: 10px; padding: 6px 4px 12px 4px; }
           .btn-container-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }

           .btn { width: 110px; height: 120px; }
           .game-info-bar { height: 25px; font-size: 0.75em; }
           .game-info-bar .game-name { font-size: 0.75em; }
           .btn .heart-icon { font-size: 0.9rem; top: 5px; right: 5px; padding: 3px; }
        }

    </style>
</head>
<body class="performance-cursor-on"> <!-- Add initial class for consistency -->
    <!-- Version text (Optional - include if you want it on this page) -->
    <!-- This style is in globalStyles.css now -->
    <div class="version-text">Apps Page</div> <!-- Update version text -->

    <!-- Unfocused Overlay - This will cover the page when window is unfocused -->
    <!-- Added here for sneak mode functionality -->
     <div id="unfocused-overlay">
         <!-- The background image is applied via CSS by the JS based on the setting -->
     </div>

    <!-- Particles.js Background -->
    <!-- This style is in globalStyles.css now -->
    <div id="particles-js"></div>

    <!-- Header -->
    <!-- Header styles are in globalStyles.css now -->
    <header>
        <!-- Ensure structure matches index.html if global CSS expects it -->
        <div class="header-container"> <!-- Use .header-container if global CSS expects this -->
            <a href="../index.html">
                 <!-- Path is correct: ../ goes up one level from Apps/ to the root -->
                <img src="../2cJw7a9.png" alt="Pulsar Logo" class="header-logo">
            </a>
            <nav>
                <ul>
                    <!-- Nav Links - Adjust paths relative to Apps/ folder -->
                    <li><a href="../index.html" class="nav-link">Home</a></li>
                    <li><a href="../Games/index.html" class="nav-link">Games</a></li> <!-- Adjusted path for Games page -->
                    <li><a href="./" class="nav-link active">Apps</a></li> <!-- Path is correct: refers to Apps/index.html -->
                    <li><a href="https://forms.gle/CkQLAFKJyxR4qTLs8" target="_blank" class="nav-link">File A DMCA Takedown Request</a></li>
                    <!-- Settings link - now uses an ID to target in JS -->
                    <li><a href="#settings" class="nav-link" id="settings-toggle-link">Settings (BETA)</a></li>
                    <li><a href="https://github.com/Yeti1o1/Pulsar" target="_blank" class="discord-btn">Built With Pulsar</a></li>
                    <li><a href="https://discord.gg/kRq8HvUrJX" target="_blank" class="discord-btn">Join The Discord</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Settings Side Menu (Content Section) - Copied from index.html context -->
    <!-- This section is now positioned fixed via CSS -->
    <section id="settings" class="content-section">
      <h2>Settings</h2>
      <div class="settings-group">
        <h3>General</h3>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label for="theme-select">Theme:</label>
          </div>
          <div class="setting-control-wrapper">
            <select id="theme-select" disabled title="Currently only Dark theme is available.">
              <option value="dark">Dark (Default)</option>
              <option value="light" disabled>Light (Not Available)</option>
            </select>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>UI Animations:</label>
          </div>
          <div class="setting-control-wrapper">
            <button id="animations-button" type="button" data-state="on">Animations ON</button>
          </div>
        </div>
      </div>
      <div class="settings-group">
          <h3>Behavior</h3>
          <div class="setting-item">
              <div class="setting-label-wrapper">
                  <label for="open-blank-button">Open Links in New Tab (about:blank):</label>
              </div>
              <div class="setting-control-wrapper">
                  <!-- **VERIFY THIS ID MATCHES** -->
                  <button id="open-blank-button" type="button" data-state="off">Open OFF</button> <!-- Default OFF -->
              </div>
          </div>
           <div class="setting-item">
              <div class="setting-label-wrapper">
                  <!-- Updated label text -->
                  <label for="sneak-mode-select">Sneak Mode (Image When Cursor Leaves Window):</label>
              </div>
              <div class="setting-control-wrapper">
                  <!-- **VERIFY THIS ID MATCHES** -->
                  <select id="sneak-mode-select">
                      <option value="off">Off</option>
                      <option value="Imgs/Google.png">Google Search</option>
                      <option value="Imgs/Google Docs.png">Google Docs</option>
                      <option value="Imgs/Google Classroom.png">Google Classroom</option>
                      <!-- Add more options here if you add more images to Imgs/ -->
                  </select>
              </div>
          </div>
      </div>
      <div class="settings-group">
        <h3>Customization</h3>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Custom Cursor:</label>
          </div>
          <div class="setting-control-wrapper">
            <!-- **VERIFY THIS ID MATCHES** -->
            <button id="enable-cursor-button" type="button" data-state="on">Cursor ON</button> <!-- Default ON -->
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Background Overlay Color:</label>
          </div>
          <div class="setting-control-wrapper">
            <div class="color-button-list" data-setting="overlay">
              <button class="settings-color-button" data-color="rgba(0, 0, 0, 0.95)" style="background-color: rgba(0, 0, 0, 0.95);" title="Black (Default)"></button> <!-- Updated default value -->
              <button class="settings-color-button" data-color="#000000" style="background-color: #000000;" title="Black"></button>
              <button class="settings-color-button" data-color="#1A1A1A" style="background-color: #1A1A1A;" title="Very Dark Grey"></button>
              <button class="settings-color-button" data-color="#333333" style="background-color: #333333;" title="Dark Grey"></button>
              <button class="settings-color-button" data-color="#555555" style="background-color: #555555;" title="Medium Grey"></button>
              <button class="settings-color-button" data-color="#777777" style="background-color: #777777;" title="Grey"></button>
              <button class="settings-color-button" data-color="#999999" style="background-color: #999999;" title="Light Grey"></button>
              <button class="settings-color-button" data-color="#CCCCCC" style="background-color: #CCCCCC;" title="Very Light Grey"></button>
              <button class="settings-color-button" data-color="#FFFFFF" style="background-color: #FFFFFF;" title="White"></button>
              <button class="settings-color-button" data-color="#FF6F61" style="background-color: #FF6F61;" title="Coral"></button>
              <button class="settings-color-button" data-color="#FFB347" style="background-color: #FFB347;" title="Peach"></button>
              <button class="settings-color-button" data-color="#FFFF66" style="background-color: #FFFF66;" title="Pastel Yellow"></button>
              <button class="settings-color-button" data-color="#B2FF66" style="background-color: #B2FF66;" title="Lime"></button>
              <button class="settings-color-button" data-color="#66FFB2" style="background-color: #66FFB2;" title="Mint"></button>
              <button class="settings-color-button" data-color="#66B2FF" style="background-color: #66B2FF;" title="Sky Blue"></button>
              <button class="settings-color-button" data-color="#B266FF" style="background-color: #B266FF;" title="Lavender"></button>
              <button class="settings-color-button" data-color="#FF66B2" style="background-color: #FF66B2;" title="Pink"></button>
              <button class="settings-color-button" data-color="#778899" style="background-color: #778899;" title="Slate Grey"></button>
              <button class="settings-color-button" data-color="#DAA520" style="background-color: #DAA520;" title="Goldenrod"></button>
              <button class="settings-color-button" data-color="#CD5C5C" style="background-color: #CD5C5C;" title="Indian Red"></button>
              <button class="settings-color-button" data-color="#007bff" style="background-color: #007bff;" title="Primary Blue"></button>
              <button class="settings-color-button" data-color="#28a745" style="background-color: #28a745;" title="Success Green"></button>
              <button class="settings-color-button" data-color="#dc3545" style="background-color: #dc3545;" title="Danger Red"></button>
              <button class="settings-color-button" data-color="#ffc107" style="background-color: #ffc107;" title="Warning Yellow"></button>
              <button class="settings-color-button" data-color="#17a2b8" style="background-color: #17a2b8;" title="Info Cyan"></button>
              <button class="settings-color-button" data-color="#e9ecef" style="background-color: #e9ecef;" title="Light"></button>
              <button class="settings-color-button" data-color="#6c757d" style="background-color: #6c757d;" title="Secondary Grey"></button>
              <button class="settings-color-button" data-color="#343a40" style="background-color: #343a40;" title="Dark"></button>
              <button class="settings-color-button" data-color="#6f42c1" style="background-color: #6f42c1;" title="Purple"></button>
              <button class="settings-color-button" data-color="#e83e8c" style="background-color: #e83e8c;" title="Fuschia"></button>
              <button class="settings-color-button" data-color="#20c997" style="background-color: #20c997;" title="Teal"></button>
              <button class="settings-color-button" data-color="#fd7e14" style="background-color: #fd7e14;" title="Orange"></button>
              <button class="settings-color-button" data-color="#6610f2" style="background-color: #6610f2;" title="Indigo"></button>
            </div>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Cursor Border Color:</label>
          </div>
          <div class="setting-control-wrapper">
            <div class="color-button-list" data-setting="cursor-border">
              <button class="settings-color-button" data-color="#FFFFFF" style="background-color: #FFFFFF;" title="White"></button>
              <button class="settings-color-button" data-color="#CCCCCC" style="background-color: #CCCCCC;" title="Light Grey"></button>
              <button class="settings-color-button" data-color="#999999" style="background-color: #999999;" title="Medium Grey"></button>
              <button class="settings-color-button" data-color="#666666" style="background-color: #666666;" title="Dark Grey"></button>
              <button class="settings-color-button" data-color="#333333" style="background-color: #333333;" title="Very Dark Grey"></button>
              <button class="settings-color-button" data-color="#FF0000" style="background-color: #FF0000;" title="Red"></button>
              <button class="settings-color-button" data-color="#00FF00" style="background-color: #00FF00;" title="Green"></button>
              <button class="settings-color-button" data-color="#0000FF" style="background-color: #0000FF;" title="Blue"></button>
              <button class="settings-color-button" data-color="#FFFF00" style="background-color: #FFFF00;" title="Yellow"></button>
              <button class="settings-color-button" data-color="#00FFFF" style="background-color: #00FFFF;" title="Cyan"></button>
            </div>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Cursor Hover Color:</label>
          </div>
          <div class="setting-control-wrapper">
            <div class="color-button-list" data-setting="cursor-hover">
              <button class="settings-color-button" data-color="#007bff" style="background-color: #007bff;" title="Primary Blue"></button>
              <button class="settings-color-button" data-color="#28a745" style="background-color: #28a745;" title="Success Green"></button>
              <button class="settings-color-button" data-color="#dc3545" style="background-color: #dc3545;" title="Danger Red"></button>
              <button class="settings-color-button" data-color="#ffc107" style="background-color: #ffc107;" title="Warning Yellow"></button>
              <button class="settings-color-button" data-color="#17a2b8" style="background-color: #17a2b8;" title="Info Cyan"></button>
              <button class="settings-color-button" data-color="#6f42c1" style="background-color: #6f42c1;" title="Purple"></button>
              <button class="settings-color-button" data-color="#e83e8c" style="background-color: #e83e8c;" title="Pink"></button>
              <button class="settings-color-button" data-color="#ffffff" style="background-color: #ffffff;" title="White"></button>
              <button class="settings-color-button" data-color="#cccccc" style="background-color: #cccccc;" title="Light Grey"></button>
              <button class="settings-color-button" data-color="#343a40" style="background-color: #343a40;" title="Dark"></button>
            </div>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Background Particles:</label>
          </div>
          <div class="setting-control-wrapper">
            <button id="particles-button" type="button" data-state="on">Particles ON</button>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Lines Between Particles:</label>
          </div>
          <div class="setting-control-wrapper">
            <button id="particles-lines-button" type="button" data-state="on" title="Toggles lines. Requires particles to be ON. The visual effect might require a brief re-render of particles.">Lines ON</button>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Moving Hero Phrases:</label>
          </div>
          <div class="setting-control-wrapper">
            <!-- This button is disabled on the Apps page -->
            <button id="moving-phrases-button" type="button" data-state="on" disabled title="This setting is only available on the Home page.">Phrases ON</button>
          </div>
        </div>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Custom Cursor Performance Mode (Snappy):</label>
          </div>
          <div class="setting-control-wrapper">
            <button id="performance-cursor-button" type="button" data-state="on">Performance ON</button>
          </div>
        </div>
      </div>
      <div class="settings-group">
        <h3>Advanced</h3>
        <div class="setting-item">
          <div class="setting-label-wrapper">
            <label>Reset all settings to default:</label>
          </div>
          <div class="setting-control-wrapper">
            <button id="reset-settings-btn">Reset</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Settings Overlay (Behind the side menu) -->
    <div id="settings-overlay"></div>


    <!-- Main App Hub Content Area -->
    <main class="hub-container">

        <!-- Search and Controls -->
        <section class="hub-controls">
            <div class="search-wrapper" id="searchWrapper">
                <input type="text" id="myInput" placeholder="Search for apps..."> <!-- Changed placeholder -->
                <button class="search-icon-btn" aria-label="Search">
                   <i class="fa fa-search"></i>
                </button>
            </div>
        </section>

        <!-- Container for Categories -->
        <div class="categories-wrapper" id="categoriesWrapper">
             <!-- Favorited Apps Section -->
            <!-- This section's display is controlled by the JS based on favorite count -->
            <section class="game-category favorites-section" id="favoritesSection">
                 <div class="category-header">
                    <h6><i class="fas fa-heart"></i> Favorited Apps</h6>
                    <div class="scroll-arrows">
                        <button class="scroll-arrow left-arrow" aria-label="Scroll Left"><i class="fas fa-angle-left"></i></button>
                        <button class="scroll-arrow right-arrow" aria-label="Scroll Right"><i class="fas fa-angle-right"></i></button>
                    </div>
                </div>
                <div class="btn-container favorite-container">
                    <!-- Favorite buttons added dynamically by JS -->
                </div>
            </section>
            <!-- All Apps Section -->
            <section class="game-category all-games-section"> <!-- Keeping game-related class names for CSS consistency -->
                 <div class="category-header">
                    <h6><i class="fas fa-border-all"></i> All Apps</h6> <!-- Changed title -->
                    <!-- Note: No scroll arrows needed for the grid container -->
                 </div>
                 <div class="btn-container-grid">
                    <button class="btn" data-path="Apps/sakura proxy/index.html" data-game-id="app-fav-sakura-proxy-index-html"><img class="imgg" src="Imgs/sakura.png" alt="Sakura Proxy"><div class="game-info-bar"><span class="game-name">Sakura Proxy</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Simple Calculator.html" data-game-id="app-fav-Simple-Calculator-html"><img class="imgg" src="Imgs/Simple Calculator.png" alt="Simple Calculator"><div class="game-info-bar"><span class="game-name">Simple Calculator</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Neutron.html" data-game-id="app-fav-Neutron-html"><img class="imgg" src="Imgs/Neutron.png" alt="Neutron"><div class="game-info-bar"><span class="game-name">Neutron</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/MiniWiki.html" data-game-id="app-fav-MiniWiki-html"><img class="imgg" src="Imgs/MiniWiki.png" alt="MiniWiki"><div class="game-info-bar"><span class="game-name">MiniWiki</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Algebra Calculator.html" data-game-id="app-fav-Algebra-Calculator-html"><img class="imgg" src="Imgs/Algebra Calculator.png" alt="Algebra Calculator"><div class="game-info-bar"><span class="game-name">Algebra Calculator</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Advanced Code Editor 1.html" data-game-id="app-fav-Advanced-Code-Editor-1-html"><img class="imgg" src="Imgs/Advanced Code Editor V1.png" alt="Advanced Code Editor V1"><div class="game-info-bar"><span class="game-name">Advanced Code Editor V1</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Advanced Code Editor 2.html" data-game-id="app-fav-Advanced-Code-Editor-2-html"><img class="imgg" src="Imgs/Advanced Code Editor V2.png" alt="Advanced Code Editor V2"><div class="game-info-bar"><span class="game-name">Advanced Code Editor V2</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Wordle Bot/Wordle Bot.html" data-game-id="app-fav-Wordle-Bot-Wordle-Bot-html"><img class="imgg" src="Imgs/Wordle Bot.png" alt="Wordle Bot"><div class="game-info-bar"><span class="game-name">Wordle Bot</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Weavesilk/index.html" data-game-id="app-fav-Weavesilk-index-html"><img class="imgg" src="Imgs/Weavesilk.png" alt="Weavesilk"><div class="game-info-bar"><span class="game-name">Weavesilk</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Turbowarp/Turbowarp.html" data-game-id="app-fav-Turbowarp-Turbowarp-html"><img class="imgg" src="Imgs/Turbowarp.png" alt="Turbowarp"><div class="game-info-bar"><span class="game-name">Turbowarp</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Ruffle/Ruffle.html" data-game-id="app-fav-Ruffle-Ruffle-html"><img class="imgg" src="Imgs/Ruffle.png" alt="Ruffle"><div class="game-info-bar"><span class="game-name">Ruffle</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/HTML Unleashed/HTML Unleashed.html" data-game-id="app-fav-HTML-Unleashed-HTML-Unleashed-html"><img class="imgg" src="Imgs/HTML Unleashed.png" alt="HTML Unleashed"><div class="game-info-bar"><span class="game-name">HTML Unleashed</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Emulators/Emulator JS/Emulator JS.html" data-game-id="app-fav-Emulators-Emulator-JS-Emulator-JS-html"><img class="imgg" src="Imgs/Emulator JS.png" alt="Emulator JS"><div class="game-info-bar"><span class="game-name">Emulator JS</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <button class="btn" data-path="Apps/Emulators/Emulator WebRetro/WebRetro.html" data-game-id="app-fav-Emulators-Emulator-WebRetro-WebRetro-html"><img class="imgg" src="Imgs/WebRetro.png" alt="WebRetro"><div class="game-info-bar"><span class="game-name">WebRetro</span></div><i class="fa fa-heart heart-icon"></i></button>
                  <!-- --- End App Buttons --- -->
                 </div>
            </section>
            <!-- Note: No other categories in this Apps page -->

        </div> <!-- Close categories-wrapper -->

        <!-- Message for no search results -->
        <p id="noResultsMessage" style="display: none; text-align: center; margin-top: 30px; font-size: 1.3em; color: #ccc;">
            No apps found matching your search. <!-- Changed message -->
        </p>

    </main>

    <!-- Custom Cursor Element (Keep this div) -->
    <!-- **VERIFY THIS ID MATCHES** -->
    <div id="custom-cursor"></div>


     <!-- --- Scripts --- -->
     <script>
        // This script contains the Apps page specific logic + integrated settings logic

        // --- Global element references ---
        // Declare these variables at the top level of this script block
        // They will be assigned element references inside DOMContentLoaded
        let customCursor;
        let navLinks;
        let body;
        let unfocusedOverlay; // Added reference for sneak mode

        // Settings menu elements
        let settingsPanel;
        let settingsOverlay;
        let settingsToggleLink; // The link in the header to open settings
        let animationsButton;
        let particlesButton;
        let particlesLinesButton;
        let movingPhrasesButton; // Although this button is hidden/disabled on Apps page, keep ref
        let performanceCursorButton;
        let resetSettingsBtn;
        let overlayColorButtonList;
        let cursorBorderColorButtonList;
        let cursorHoverColorButtonList;
        let sneakModeSelect; // Added reference for sneak mode select
        let themeSelect; // Added reference for theme select
        let openBlankButton; // Added reference for Open in Blank button
        let enableCursorButton; // Added reference for Enable Cursor button


        // Page-specific elements
        let searchInput;
        let searchIconBtn;
        let categoriesWrapper;
        let noResultsMessage;
        let mainContainer; // Added reference for the main content wrapper

        // Store the hash that caused the menu to open (if any)
        let hashThatOpenedSettings = null;

         // Store listeners for mouseleave/mouseenter for sneak mode
        let mouseEnterListener = null;
        let mouseLeaveListener = null;


        // --- Custom Cursor Script (Adjusted) ---
        document.addEventListener('mousemove', (e) => {
          customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
          const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off', performanceCursorOn: 'on' }; // Default settings if globalSettings not ready

          if(customCursor && currentSettings.enableCustomCursor === 'on') {
            if (currentSettings.performanceCursorOn === 'on') {
                 // Defer updates using requestAnimationFrame for potentially better performance
                 if (!customCursor._rafId) {
                     customCursor._rafId = requestAnimationFrame(() => {
                         customCursor.style.setProperty('--mouse-x', `${e.clientX}px`);
                         customCursor.style.setProperty('--mouse-y', `${e.clientY}px`);
                         customCursor._rafId = null; // Clear the ID after update
                     });
                 }
            } else {
                 // Update directly for standard mode
                 customCursor.style.setProperty('--mouse-x', `${e.clientX}px`);
                 customCursor.style.setProperty('--mouse-y', `${e.clientY}px`);
                 if (customCursor._rafId) {
                     cancelAnimationFrame(customCursor._rafId);
                     customCursor._rafId = null;
                 }
            }
          } else {
               // Ensure RAF loop is stopped if cursor is disabled or element not found
               if (customCursor && customCursor._rafId) {
                   cancelAnimationFrame(customCursor._rafId);
                   customCursor._rafId = null;
               }
          }
        });

        document.addEventListener('mousedown', (e) => {
             customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
             settingsPanel = settingsPanel || document.getElementById('settings'); // Ensure reference is fresh
             settingsToggleLink = settingsToggleLink || document.getElementById('settings-toggle-link'); // Ensure reference is fresh

             const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off' }; // Default settings

            if (!customCursor || currentSettings.enableCustomCursor !== 'on') return;

            // Prevent click animation if clicking inside the settings panel or its toggle link
            // Check if the event target is inside the settings panel OR is the settings toggle link
            // Using `closest` is robust as it checks the element itself and its ancestors
            const isClickInsideSettingsPanel = settingsPanel && e.target.closest('#settings');
            const isClickOnSettingsToggle = settingsToggleLink && e.target.closest('#settings-toggle-link');

            // Only add the 'clicked' class if the click is *not* inside the settings panel or on the toggle link
            if (!isClickInsideSettingsPanel && !isClickOnSettingsToggle) {
                 customCursor.classList.add('clicked');
            }
        });

        document.addEventListener('mouseup', () => {
           customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
            const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off' }; // Default settings
           if (customCursor && currentSettings.enableCustomCursor === 'on') {
               customCursor.classList.remove('clicked');
           }
        });

        // Selectors for elements that should change the cursor appearance on hover
        const interactiveElementsSelectors = 'a, button, input[type="text"], select, [role="button"], .scroll-arrow, .settings-color-button, .heart-icon'; // Added .heart-icon

        function addInteractiveCursorListeners() {
            customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
             const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off' }; // Default settings
            const cursorEnabled = currentSettings.enableCustomCursor === 'on';


            if (!customCursor) {
                // console.warn("Custom cursor element not found, cannot add interactive listeners. Retrying..."); // Debug missing element
                // requestAnimationFrame(addInteractiveCursorListeners); // Retry until found - removed to avoid infinite loops if element is truly missing
                return;
            }

            // Remove existing listeners from previously selected elements to avoid duplicates
            // Iterate over known interactive elements
             document.querySelectorAll(interactiveElementsSelectors).forEach(el => {
                 // Use specific stored property names to remove the correct listeners
                 if (el._interactiveEnterListener) {
                     el.removeEventListener('mouseenter', el._interactiveEnterListener);
                     el.removeEventListener('mouseleave', el._interactiveLeaveListener);
                     // Clean up the stored properties after removal
                     delete el._interactiveEnterListener;
                     delete el._interactiveLeaveListener;
                 }
             });


             if (cursorEnabled) {
                const interactiveElements = document.querySelectorAll(interactiveElementsSelectors);
                interactiveElements.forEach(el => {
                    // Store the specific listener function references on the element
                    el._interactiveEnterListener = handleInteractiveEnter;
                    el._interactiveLeaveListener = handleInteractiveLeave;
                     // Add new listeners
                    el.addEventListener('mouseenter', el._interactiveEnterListener);
                    el.addEventListener('mouseleave', el._interactiveLeaveListener);
                });
                 // console.log(`Added interactive cursor listeners to ${interactiveElements.length} elements.`); // Debug count
             } else {
                 // If cursor is disabled, ensure cursor is removed from interactive elements if it was added
                  customCursor.classList.remove('on-interactive');
             }
        }

        function handleInteractiveEnter() {
             customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
            const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off' }; // Default settings
            if(customCursor && currentSettings.enableCustomCursor === 'on') {
                 customCursor.classList.add('on-interactive');
            }
        }

        function handleInteractiveLeave() {
            customCursor = customCursor || document.getElementById('custom-cursor'); // Ensure reference is fresh
             const currentSettings = window.getSettings ? window.getSettings() : { enableCustomCursor: 'off' }; // Default settings
            if(customCursor && currentSettings.enableCustomCursor === 'on') {
                 customCursor.classList.remove('on-interactive');
            }
        }
        // --- END Custom Cursor Script ---


        // --- Sneak Mode (Cursor Leaves) Script (Copied and adapted) ---
        function handleMouseEnter() {
            unfocusedOverlay = unfocusedOverlay || document.getElementById('unfocused-overlay'); // Ensure reference is fresh
            body = body || document.body; // Ensure reference is fresh
            mainContainer = mainContainer || document.querySelector('main.hub-container'); // Ensure reference is fresh

            const currentSettings = window.getSettings ? window.getSettings() : { sneakModeApp: 'off' }; // Default settings

            // Only react if the feature is ON (not 'off') and the overlay is currently visible (means mouse was outside)
            if (currentSettings.sneakModeApp !== 'off' && unfocusedOverlay && body && unfocusedOverlay.style.display !== 'none') {
                console.log("Sneak Mode: Mouse entered document. Hiding overlay and restoring content visibility.");
                unfocusedOverlay.style.display = 'none';
                body.classList.remove('unfocused');
                 // Restore visibility of the main content container
                 if (mainContainer) {
                     mainContainer.style.display = 'block'; // Or revert to its default display style
                      // Re-trigger filterApps to ensure correct element visibility *within* the container
                     requestAnimationFrame(() => filterApps());
                 }
            }
        }

        function handleMouseLeave() {
            unfocusedOverlay = unfocusedOverlay || document.getElementById('unfocused-overlay'); // Ensure reference is fresh
            body = body || document.body; // Ensure reference is fresh
            mainContainer = mainContainer || document.querySelector('main.hub-container'); // Ensure reference is fresh

            const currentSettings = window.getSettings ? window.getSettings() : { sneakModeApp: 'off' }; // Default settings

            // Only react if the feature is ON (not 'off') and the overlay is currently hidden (means mouse was inside)
            if (currentSettings.sneakModeApp !== 'off' && unfocusedOverlay && body && unfocusedOverlay.style.display === 'none') {
                console.log("Sneak Mode: Mouse left document. Showing overlay and hiding main content.");
                unfocusedOverlay.style.display = 'block';
                body.classList.add('unfocused'); // Add class to potentially disable pointer events on content (CSS)
                 // Hide the main content container
                 if (mainContainer) {
                    mainContainer.style.display = 'none';
                 }
            }
        }

        // The enableSneakMode and disableSneakMode functions are expected to be in globalSettings.js
        // and will call handleMouseEnter/handleMouseLeave when the setting is applied.
        // Ensure globalSettings.js is correctly linked BEFORE this script block.
        // If globalSettings.js defines these functions, they don't need to be redefined here.
        // If globalSettings.js *calls* these functions (handleMouseEnter/Leave) directly,
        // then these definitions are needed here. Let's assume they are called by globalSettings.js

         // Define them here defensively if globalSettings.js doesn't define them,
         // but they are called by its applySettings.
        /*
         if (typeof enableSneakMode === 'undefined') {
             window.enableSneakMode = function() {
                 if (mouseEnterListener === null) {
                      mouseEnterListener = handleMouseEnter;
                      mouseLeaveListener = handleMouseLeave;
                      document.documentElement.addEventListener('mouseenter', mouseEnterListener);
                      document.documentElement.addEventListener('mouseleave', mouseLeaveListener);
                      console.log("Sneak Mode (Mouse Leave) listeners enabled.");
                 }
             };
         }
         if (typeof disableSneakMode === 'undefined') {
             window.disableSneakMode = function() {
                  if (mouseEnterListener !== null) {
                     document.documentElement.removeEventListener('mouseenter', mouseEnterListener);
                     document.documentElement.removeEventListener('mouseleave', mouseLeaveListener);
                     mouseEnterListener = null;
                     mouseLeaveListener = null;
                      console.log("Sneak Mode (Mouse Leave) listeners disabled.");
                  }
                  // Ensure content is visible and overlay is hidden when disabling the feature
                  unfocusedOverlay = unfocusedOverlay || document.getElementById('unfocused-overlay'); // Ensure reference is fresh
                  if (unfocusedOverlay && unfocusedOverlay.style.display !== 'none') {
                       handleMouseEnter(); // This will hide the overlay and show content if needed
                  }
                  // Also ensure the background image is cleared - handled by globalSettings.js applySettings
             };
         }
         */
        // Assuming enableSneakMode and disableSneakMode are correctly defined and called
        // by applySettings in globalSettings.js, which is linked above.

        // --- END Sneak Mode (Cursor Leaves) Script ---


        // --- Settings Side Menu Toggle Logic (Copied) ---
        function toggleSettingsMenu(open) {
             // Ensure references are set before using
             settingsPanel = settingsPanel || document.getElementById('settings');
             settingsOverlay = settingsOverlay || document.getElementById('settings-overlay');
             body = body || document.body;
             navLinks = navLinks || document.querySelectorAll('.nav-link');
             settingsToggleLink = settingsToggleLink || document.getElementById('settings-toggle-link');

             if (!settingsPanel || !settingsOverlay || !body || !navLinks || !settingsToggleLink) {
                 console.error("toggleSettingsMenu: Settings elements not found, cannot toggle menu.");
                 return;
             }

             const isOpen = settingsPanel.classList.contains('is-visible');
             const shouldOpen = open === undefined ? !isOpen : open;

             if (shouldOpen && !isOpen) {
                 console.log("toggleSettingsMenu: Opening settings menu");
                 settingsPanel.classList.add('is-visible');
                 settingsOverlay.classList.add('is-visible');
                 body.classList.add('settings-open'); // Disable body scroll and apply blur/pointer-events to main content
                 settingsToggleLink.setAttribute('aria-expanded', 'true');
                 // Add Escape key listener to close
                 document.addEventListener('keydown', handleEscapeKey);
                 // Re-add interactive cursor listeners to include elements *inside* the settings panel now that it's visible
                 requestAnimationFrame(addInteractiveCursorListeners);

                  // Update active state for the settings link when opening
                 navLinks.forEach(link => {
                     // Check if the link's href, resolved against the current URL, points to the settings hash
                      try {
                          const linkUrl = new URL(link.href, window.location.href);
                          const currentUrl = new URL(window.location.href);
                           // Check if same origin, same path, and hash is #settings
                           if (linkUrl.origin === currentUrl.origin && linkUrl.pathname === currentUrl.pathname && linkUrl.hash === '#settings') {
                                link.classList.add('active');
                           } else {
                               link.classList.remove('active');
                           }
                      } catch(e) {
                           console.error("toggleSettingsMenu: Error parsing URL for settings link check:", link.href, e);
                            // Fallback check
                           if (link.getAttribute('href') === '#settings') {
                               link.classList.add('active');
                           } else {
                               link.classList.remove('active');
                           }
                      }
                 });

             } else if (!shouldOpen && isOpen) {
                 console.log("toggleSettingsMenu: Closing settings menu");
                 settingsPanel.classList.remove('is-visible');
                 settingsOverlay.classList.remove('is-visible');
                 body.classList.remove('settings-open'); // Re-enable body scroll and remove blur/pointer-events
                 settingsToggleLink.setAttribute('aria-expanded', 'false');
                 // Remove Escape key listener
                 document.removeEventListener('keydown', handleEscapeKey);
                 // Re-add interactive cursor listeners (settings panel elements are now effectively hidden/inactive)
                 requestAnimationFrame(addInteractiveCursorListeners);

                 // Update active state for nav links when closing
                 // If the hash *was* #settings and we're closing, we need to update the nav active state
                  updateNavActiveState(window.location.hash); // Update nav state based on the current hash

             } else {
                  // console.log("toggleSettingsMenu: No state change needed."); // Debug no-op
             }
        }

        function handleEscapeKey(event) {
             // Ensure settingsPanel reference is available and menu is open
             settingsPanel = settingsPanel || document.getElementById('settings'); // Ensure reference is fresh
             if (!settingsPanel || !settingsPanel.classList.contains('is-visible')) return;

             if (event.key === 'Escape') {
                 event.preventDefault(); // Prevent default browser behavior for Escape
                 toggleSettingsMenu(false); // Close the menu
                  // If the hash was #settings because of manual navigation, change it back
                 if (window.location.hash === '#settings') {
                      // On apps page, if closing settings opened by hash, just remove the hash
                     history.replaceState(null, '', window.location.pathname + window.location.search);
                     // hashchange doesn't fire for replaceState, toggleSettingsMenu(false) calls updateNavActiveState
                 }
                  hashThatOpenedSettings = null; // Reset flag
             }
        }
        // --- END Settings Side Menu Toggle Logic ---

        // --- Navigation Active State Update (Adapted) ---
        // This function updates the 'active' class on header navigation links.
         function updateNavActiveState(hash) {
             // console.log(`updateNavActiveState called with hash: "${hash}"`); // Debug
             navLinks = navLinks || document.querySelectorAll('.nav-link'); // Ensure ref is fresh
             settingsPanel = settingsPanel || document.getElementById('settings'); // Ensure ref is fresh


             if (!navLinks || !settingsPanel) {
                  console.error("Nav links or settings panel not found for updateNavActiveState.");
                  return;
             }

             navLinks.forEach(link => {
                 link.classList.remove('active'); // Start by removing active from all links
                 try {
                     const linkUrl = new URL(link.href, window.location.href);
                     const currentUrl = new URL(window.location.href);

                     // Normalize link path by removing index.html and trailing slashes for comparison
                     const normalizePath = (url) => url.pathname.replace(/index\.html$/, '').replace(/\/$/, '');
                     const normalizedLinkPath = normalizePath(linkUrl);
                     const normalizedCurrentPath = normalizePath(currentUrl);

                     // Check if the link points to the *current* page's root path
                     const isCurrentPageLink = linkUrl.origin === currentUrl.origin && normalizedLinkPath === normalizedCurrentPath;
                     const isSettingsLink = linkUrl.origin === currentUrl.origin && linkUrl.pathname === currentUrl.pathname && linkUrl.hash === '#settings';

                     // The link for the current page (Apps hub) should be active if settings is NOT open
                      if (isCurrentPageLink && !isSettingsLink && !settingsPanel.classList.contains('is-visible')) {
                           link.classList.add('active');
                      }
                     // The settings link should be active if the settings panel is open
                     else if (isSettingsLink && settingsPanel.classList.contains('is-visible')) {
                         link.classList.add('active');
                     }
                     // Links to other pages (Home, Games) will not be active on the Apps page.
                      // No need for extra logic here, the first condition handles the current page link.

                 } catch (e) {
                   console.error("Error parsing URL for nav link in updateNavActiveState:", link.href, e);
                    // Fallback logic if URL parsing fails
                    const href = link.getAttribute('href');
                    const isSettingsLink = href === '#settings';
                    const currentPath = window.location.pathname.replace(/\/$/, ''); // Remove trailing slash
                     // Simple check: does the current path end with the link's path (ignoring ../)?
                    const linkPath = href.replace(/^\.\.\//, '').replace(/index\.html$/, '').replace(/\/$/, '');
                    const isCurrentPageLink = currentPath.endsWith(linkPath);

                    if (isSettingsLink && settingsPanel?.classList.contains('is-visible')) {
                         link.classList.add('active');
                    } else if (isCurrentPageLink && !settingsPanel?.classList.contains('is-visible')) {
                         link.classList.add('active');
                    }
               }
             });
             // console.log("Nav active states updated."); // Debug
         }


        // --- Utility: Debounce Function ---
        function debounce(func, wait, immediate) {
          var timeout;
          return function() {
            var context = this, args = arguments;
            var later = function() {
              timeout = null;
              if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
          };
        }

        // --- Utility: Get Button Name (Adjusted for new structure) ---
        // Robust helper to extract app name
        function getButtonName(button) {
           // Try span.game-name inside .game-info-bar first (New structure)
           const spanText = button.querySelector('.game-info-bar .game-name')?.textContent.trim();
           if (spanText) return spanText;

           // Fallback 1: Look for text node directly inside the button (Original structure - less likely now)
           let name = "";
           button.childNodes.forEach(node => {
             if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "") {
               name = node.textContent.trim();
             }
           });
           if (name) return name;

           // Fallback 2: img alt
           const imgAlt = button.querySelector('.imgg')?.alt;
           if (imgAlt) return imgAlt;

           // Final fallback: data-path processing
           const path = button.getAttribute('data-path');
           if (path) {
               // Split by / and ., take the last part before ., replace - and _ with spaces
               let pathName = path.split('/').pop().split('.')[0].replace(/[-_]/g, ' ');
               // Capitalize first letter of each word
               return pathName.replace(/\b\w/g, l => l.toUpperCase());
           }

           return 'Unknown App'; // Changed default name
        }


      // --- Scroll Arrow Logic (Copied and adapted) ---
      // Define the scroll arrow logic function
      // This function is designed to be called for each category that *might* need scroll arrows.
      function setupScrollArrows(category) {
        // Ensure we select the correct container class(es)
        // Targets .favorite-container for the row and ignores .btn-container-grid
        const btnContainer = category.querySelector('.favorite-container');

        // Only proceed if this category *is* horizontal (.favorite-container) and has scroll arrows
        const leftArrow = category.querySelector('.scroll-arrow.left-arrow');
        const rightArrow = category.querySelector('.scroll-arrow.right-arrow');

        // Exit if this isn't a horizontal scrolling category or elements are missing
        if (!btnContainer || !leftArrow || !rightArrow) {
            // If arrows are present but the correct container (.favorite-container) isn't, hide them
             if (leftArrow) leftArrow.style.display = 'none';
             if (rightArrow) rightArrow.style.display = 'none';
            return; // Skip setup if not applicable
        } else {
             // Ensure arrows are visible initially if elements exist
             leftArrow.style.display = 'flex';
             rightArrow.style.display = 'flex';
        }

        // Scroll amount based on a percentage of container width, with a minimum
        let scrollAmount = btnContainer.clientWidth * 0.8;
        const updateScrollAmount = () => {
           scrollAmount = btnContainer.clientWidth * 0.8; // Re-calculate on resize
           if (scrollAmount < 200) scrollAmount = 200; // Minimum scroll amount
        };

        // Initial calculation
        updateScrollAmount();


        function updateArrowVisibility() {
             // Hide arrows entirely if the category or container is hidden or has no visible items
            // Use offsetParent to check if an element is actually rendered and part of the layout
             if (!category.offsetParent || !btnContainer.offsetParent ||
                 window.getComputedStyle(btnContainer).display === 'none' ||
                 window.getComputedStyle(category).display === 'none') {
                 // console.log(`Arrows hidden for ${category.querySelector('h6')?.textContent || 'Unknown'} - container/category hidden.`); // Debug
                leftArrow.classList.add('hidden');
                rightArrow.classList.add('hidden');
                 // Ensure arrow buttons are disabled for accessibility
                 leftArrow.disabled = true;
                 rightArrow.disabled = true;
                return;
            }

             // Check if there are any visible buttons in the container
             const visibleButtons = Array.from(btnContainer.querySelectorAll('.btn'))
                 .filter(btn => window.getComputedStyle(btn).display !== 'none');
             if (visibleButtons.length === 0) {
                  // console.log(`Arrows hidden for ${category.querySelector('h6')?.textContent || 'Unknown'} - no visible buttons.`); // Debug
                  leftArrow.classList.add('hidden');
                  rightArrow.classList.add('hidden');
                  leftArrow.disabled = true;
                  rightArrow.disabled = true;
                  return;
             }

            const tolerance = 5; // Small tolerance for floating point issues
            const maxScrollLeft = btnContainer.scrollWidth - btnContainer.clientWidth;
            const currentScrollLeft = btnContainer.scrollLeft;

             // Check if scrolling is actually needed horizontally
             // Only show arrows if the content width is greater than the container width plus a tolerance
             const canScrollHorizontally = btnContainer.scrollWidth > btnContainer.clientWidth + tolerance;


             // Ensure arrows are displayed (flex as per CSS) if they *might* be needed
             leftArrow.style.display = 'flex';
             rightArrow.style.display = 'flex';


            // Update left arrow visibility (only if horizontal scrolling is possible)
            if (canScrollHorizontally && currentScrollLeft > tolerance) {
                leftArrow.classList.remove('hidden');
                 leftArrow.disabled = false; // Enable button
                // Add pulse animation only when it becomes visible
                if (!leftArrow._wasVisible) {
                    leftArrow.classList.add('show-pulse');
                    setTimeout(() => leftArrow.classList.remove('show-pulse'), 400); // Remove pulse after anim
                }
                leftArrow._wasVisible = true; // Mark as was visible
            } else {
                leftArrow.classList.add('hidden');
                leftArrow.disabled = true; // Disable button
                leftArrow._wasVisible = false; // Mark as was not visible
            }

            // Update right arrow visibility (only if horizontal scrolling is possible)
            if (canScrollHorizontally && currentScrollLeft < maxScrollLeft - tolerance) {
                rightArrow.classList.remove('hidden');
                 rightArrow.disabled = false; // Enable button
                 // Add pulse animation only when it becomes visible
                 if (!rightArrow._wasVisible) {
                     rightArrow.classList.add('show-pulse');
                     setTimeout(() => rightArrow.classList.remove('show-pulse'), 400); // Remove pulse after anim
                 }
                 rightArrow._wasVisible = true; // Mark as was visible
            } else {
                rightArrow.classList.add('hidden');
                rightArrow.disabled = true; // Disable button
                rightArrow._wasVisible = false; // Mark as was not visible
            }
            // console.log(`Arrows updated for ${category.querySelector('h6')?.textContent || 'Unknown'}: Left Hidden=${leftArrow.classList.contains('hidden')}, Right Hidden=${rightArrow.classList.contains('hidden')}, Can Scroll=${canScrollHorizontally}`); // Debug visibility
        }

        // Use a debounced version for scroll and observer events
        const debouncedUpdateArrows = debounce(updateArrowVisibility, 50);
        category._updateArrowVisibility = debouncedUpdateArrows; // Store on category for external triggers

        // Listen for scroll events on the button container
        // Remove existing scroll listener before adding
        if (btnContainer._scrollListener) {
            btnContainer.removeEventListener('scroll', btnContainer._scrollListener);
        }
        btnContainer.addEventListener('scroll', debouncedUpdateArrows);
        btnContainer._scrollListener = debouncedUpdateArrows;


        // Use MutationObserver to detect changes in the number or visibility of buttons
        // Disconnect existing observer before creating a new one
         if (category._mutationObserver) {
             category._mutationObserver.disconnect();
         }
        const mutationObserver = new MutationObserver(debouncedUpdateArrows);
        mutationObserver.observe(btnContainer, { childList: true, attributes: true, subtree: true }); // Watch for button additions/removals/attribute changes (like 'hidden')
         category._mutationObserver = mutationObserver; // Store observer


        // Use ResizeObserver to detect changes in container size or category size
         // Disconnect existing observer before creating a new one
         if (category._resizeObserver) {
             category._resizeObserver.disconnect();
         }
        const resizeObserver = new ResizeObserver(() => {
             // console.log("Resize detected, updating scroll amount and arrow visibility."); // Debug resize
            updateScrollAmount(); // Recalculate scroll amount on resize
            debouncedUpdateArrows(); // Update arrow visibility
        });
        resizeObserver.observe(btnContainer);
        resizeObserver.observe(category); // Also observe the category element itself
         category._resizeObserver = resizeObserver; // Store observer


        // Easing function: ease-in-out quadratic
        const easeInOutQuad = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        // Custom scroll animation with requestAnimationFrame
        let isAnimating = false;
        let animationFrameId = null;
        const animateScroll = (direction, duration = 400) => {
            if (isAnimating) return; // Prevent multiple animations at once
            isAnimating = true;

            const start = btnContainer.scrollLeft;
            // Calculate target, ensuring it doesn't exceed bounds
            let target = start + direction * scrollAmount;
            const maxScrollLeft = btnContainer.scrollWidth - btnContainer.clientWidth;
            target = Math.max(0, Math.min(target, maxScrollLeft)); // Clamp target between 0 and maxScrollLeft

            const startTime = performance.now();

            const step = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1); // Clamp progress to 1
                const easedProgress = easeInOutQuad(progress); // Apply easing

                btnContainer.scrollLeft = start + (target - start) * easedProgress;

                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(step);
                } else {
                    isAnimating = false;
                    // Ensure scroll position is exactly the target at the end
                    btnContainer.scrollLeft = target;
                     // Update arrows immediately after animation finishes
                     updateArrowVisibility();
                }
            };

            animationFrameId = requestAnimationFrame(step);
        };

        // Function to stop any ongoing scroll animation
        const stopScrollAnimation = () => {
             if (animationFrameId !== null) {
                  cancelAnimationFrame(animationFrameId);
                  animationFrameId = null;
             }
             isAnimating = false;
        };

        const scrollStep = (direction) => {
            // Stop current animation if one is running before starting a new one
            stopScrollAnimation();
            if (isNaN(scrollAmount) || scrollAmount <= 0) {
                // console.warn("Scroll amount is not valid, cannot scroll.");
                return;
            }
            animateScroll(direction, 400); // 400ms duration
        };


        // Remove existing arrow click/hold listeners before adding
        // Use a consistent property name to store all related listeners
        const existingListeners = category._scrollStepListeners;
        if (existingListeners) {
            leftArrow.removeEventListener('click', existingListeners.left);
            rightArrow.removeEventListener('click', existingListeners.right);

            leftArrow.removeEventListener('mousedown', existingListeners.leftHoldStart);
            leftArrow.removeEventListener('mouseup', existingListeners.leftHoldStop);
            leftArrow.removeEventListener('mouseleave', existingListeners.leftHoldStop);
            leftArrow.removeEventListener('touchstart', existingListeners.leftHoldStartTouch, { passive: false });
            leftArrow.removeEventListener('touchend', existingListeners.leftHoldStop);
            leftArrow.removeEventListener('touchcancel', existingListeners.leftHoldStop);

            rightArrow.removeEventListener('mousedown', existingListeners.rightHoldStart);
            rightArrow.removeEventListener('mouseup', existingListeners.rightHoldStop);
            rightArrow.removeEventListener('mouseleave', existingListeners.rightHoldStop); // Corrected to mouseleave
            rightArrow.removeEventListener('touchstart', existingListeners.rightHoldStartTouch, { passive: false });
            rightArrow.removeEventListener('touchend', existingListeners.rightHoldStop);
            rightArrow.removeEventListener('touchcancel', existingListeners.rightHoldStop); // Corrected to rightHoldStop

             // Clean up the stored property
             delete category._scrollStepListeners;
             // console.log(`Removed previous scroll arrow listeners for category ${category.querySelector('h6')?.textContent}`); // Debug removal
        }


        // Add click listeners for single steps
        const leftClickListener = () => scrollStep(-1);
        const rightClickListener = () => scrollStep(1);
        leftArrow.addEventListener('click', leftClickListener);
        rightArrow.addEventListener('click', rightClickListener);

        // Add hold-to-scroll functionality
        let scrollHoldInterval = null;
        const startHoldScrolling = (direction) => {
            stopHoldScrolling(); // Stop any existing hold interval
            stopScrollAnimation(); // Stop any single-step animation
             // console.log(`Start hold scrolling: ${direction}`); // Debug hold
            // Start rapid scrolling
            scrollHoldInterval = setInterval(() => {
                 scrollStep(direction); // Re-use scrollStep which handles animation
            }, 100); // Adjust interval for speed (e.g., 100ms)
        };
        const stopHoldScrolling = () => {
            if (scrollHoldInterval !== null) {
                 clearInterval(scrollHoldInterval);
                 scrollHoldInterval = null;
                 // console.log("Stop hold scrolling."); // Debug hold stop
            }
        };

        const leftHoldStart = () => startHoldScrolling(-1);
        const leftHoldStop = stopHoldScrolling;
        const leftHoldStartTouch = (e) => { e.preventDefault(); startHoldScrolling(-1); }; // Prevent default touch behavior

        const rightHoldStart = () => startHoldScrolling(1);
        const rightHoldStop = stopHoldScrolling;
        const rightHoldStartTouch = (e) => { e.preventDefault(); startHoldScrolling(1); }; // Prevent default touch behavior


        leftArrow.addEventListener('mousedown', leftHoldStart);
        leftArrow.addEventListener('mouseup', leftHoldStop);
        leftArrow.addEventListener('mouseleave', leftHoldStop);
        leftArrow.addEventListener('touchstart', leftHoldStartTouch, { passive: false });
        leftArrow.addEventListener('touchend', leftHoldStop);
        leftArrow.addEventListener('touchcancel', leftHoldStop);


        rightArrow.addEventListener('mousedown', rightHoldStart);
        rightArrow.addEventListener('mouseup', rightHoldStop);
        rightArrow.addEventListener('mouseleave', rightHoldStop); // Corrected to mouseleave
        rightArrow.addEventListener('touchstart', rightHoldStartTouch, { passive: false });
        rightArrow.addEventListener('touchend', rightHoldStop);
        rightArrow.addEventListener('touchcancel', rightHoldStop); // Corrected to rightHoldStop


        // Store listeners on category element for easy removal if needed later
        category._scrollStepListeners = {
            left: leftClickListener, right: rightClickListener,
            leftHoldStart: leftHoldStart, leftHoldStop: leftHoldStop, leftHoldStartTouch: leftHoldStartTouch,
            rightHoldStart: rightHoldStart, rightHoldStop: rightHoldStop, rightHoldStartTouch: rightHoldStartTouch
        };
         // console.log(`Attached new scroll arrow listeners for category ${category.querySelector('h6')?.textContent}`); // Debug attachment


        // Initial visibility update - needs to be delayed slightly to allow layout calculation
        requestAnimationFrame(() => {
             requestAnimationFrame(() => { // Double RAF to ensure element is rendered and sized
                 updateArrowVisibility();
             });
        });

         // Clean up observers and listeners when the category element is removed from the DOM
         // Disconnect existing observer before creating a new one
         if (category._removalObserver) {
             category._removalObserver.disconnect();
         }
         const removalObserver = new MutationObserver((mutations, observer) => {
              mutations.forEach(mutation => {
                   if (mutation.removedNodes) {
                        mutation.removedNodes.forEach(node => {
                             // Check if the removed node is the category element itself
                             if (node === category) {
                                  console.log(`Clean up triggered for category: ${category.querySelector('h6')?.textContent || 'Unknown'}`);
                                  // Clean up all associated listeners and observers
                                  const listeners = node._scrollStepListeners; // Use the stored property
                                  if (listeners) {
                                      // Remove click listeners
                                      leftArrow?.removeEventListener('click', listeners.left);
                                      rightArrow?.removeEventListener('click', listeners.right);

                                      // Remove hold listeners (mouse)
                                      leftArrow?.removeEventListener('mousedown', listeners.leftHoldStart);
                                      leftArrow?.removeEventListener('mouseup', listeners.leftHoldStop);
                                      leftArrow?.removeEventListener('mouseleave', listeners.leftHoldStop);

                                      rightArrow?.removeEventListener('mousedown', listeners.rightHoldStart);
                                      rightArrow?.removeEventListener('mouseup', listeners.rightHoldStop);
                                      rightArrow?.removeEventListener('mouseleave', listeners.rightHoldStop); // Corrected

                                      // Remove hold listeners (touch)
                                      leftArrow?.removeEventListener('touchstart', listeners.leftHoldStartTouch, { passive: false });
                                      leftArrow?.removeEventListener('touchend', listeners.leftHoldStop);
                                      leftArrow?.removeEventListener('touchcancel', listeners.leftHoldStop);

                                      rightArrow?.removeEventListener('touchstart', listeners.rightHoldStartTouch, { passive: false });
                                      rightArrow?.removeEventListener('touchend', listeners.rightHoldStop);
                                      rightArrow?.removeEventListener('touchcancel', listeners.rightHoldStop); // Corrected

                                      // Stop any ongoing hold scrolling interval
                                      stopHoldScrolling();

                                       // Clean up the stored property
                                       delete node._scrollStepListeners;
                                  }

                                   // Remove scroll listener from the container
                                   if (btnContainer && btnContainer._scrollListener) {
                                       btnContainer.removeEventListener('scroll', btnContainer._scrollListener);
                                        delete btnContainer._scrollListener;
                                   }

                                    // Disconnect observers
                                   if (node._mutationObserver) {
                                        node._mutationObserver.disconnect();
                                        delete node._mutationObserver;
                                   }
                                   if (node._resizeObserver) {
                                        node._resizeObserver.disconnect();
                                        delete node._resizeObserver;
                                   }

                                   // Disconnect the removal observer itself
                                   observer.disconnect();
                                    delete node._removalObserver; // Clean up the stored property

                                   console.log(`Cleaned up scroll logic for removed category: ${node.querySelector('h6')?.textContent || 'Unknown'}`);
                             }
                        });
                   }
              });
         });
         // Observe the parent element of the category, or the body if it has no parent yet
         removalObserver.observe(category.parentElement || document.body, { childList: true });
          category._removalObserver = removalObserver; // Store observer
    }
    // --- END Scroll Arrow Logic ---


      // --- Search Filter Logic (Adjusted for "Apps") ---
      function filterApps() {
        // Ensure references are fresh
        searchInput = searchInput || document.getElementById('myInput');
        categoriesWrapper = categoriesWrapper || document.getElementById('categoriesWrapper');
        noResultsMessage = noResultsMessage || document.getElementById('noResultsMessage');

        if (!searchInput || !categoriesWrapper || !noResultsMessage) {
             console.warn("Filter elements not found, skipping filter.");
             return;
        }

        const filter = searchInput.value.toUpperCase().trim();
        // Select all categories, including favorites for filtering their contents
        const categories = categoriesWrapper.querySelectorAll('.game-category');
        let hasVisibleItemsOverall = false; // Track if ANY item is visible after filtering across all categories

        // console.log(`--- Filtering for: "${filter}" ---`);

        categories.forEach(category => {
          // Select the correct container within the category (favorite or grid)
          const btnContainer = category.querySelector('.favorite-container, .btn-container-grid');
          if (!btnContainer) return; // Skip categories without a button container

          const buttons = btnContainer.querySelectorAll('.btn');
          let categoryHasVisibleButton = false; // Does this specific category have a button visible after filtering?

          buttons.forEach(button => {
            // Get the name robustly
            const itemName = getButtonName(button);
            const buttonMatches = itemName.toUpperCase().includes(filter);

            // Decide whether to show or hide the button based on the filter
            if (filter === '' || buttonMatches) {
              // If filter is empty, or button matches filter, show it
              if (button.classList.contains('hidden')) {
                   button.classList.remove('hidden');
              }
              hasVisibleItemsOverall = true; // At least one item is visible overall
              categoryHasVisibleButton = true; // Found a visible button in this category
            } else {
               // Filter is active and button does not match, hide it
               if (!button.classList.contains('hidden')) {
                 button.classList.add('hidden');
               }
            }
          });

           // Update category display based on filter
           // Favorites section visibility is controlled by its own logic (updateFavoritesSectionVisibility)
           // based on whether it has any children *at all*.
           // Non-favorites sections are hidden if the filter is active and no items within them match.
           if (filter !== '') {
               if (!category.classList.contains('favorites-section')) {
                    category.style.display = categoryHasVisibleButton ? '' : 'none'; // Revert to CSS default or hide
               }
           } else {
               // When filter is cleared, make all non-favorite categories visible again
               if (!category.classList.contains('favorites-section')) {
                    category.style.display = ''; // Revert to CSS default
               }
           }

          // Trigger arrow update for this category *after* potentially changing button visibility
          // Add a small delay to allow layout to settle. Use the stored update function.
          const updateFunc = category._updateArrowVisibility;
          if (typeof updateFunc === 'function') {
              // Use rAF + setTimeout for robust post-layout update
              requestAnimationFrame(() => setTimeout(updateFunc, 10));
          }
        });

        // Handle "No Results" message
        // Show the message only if the filter is NOT empty AND no items were marked visible anywhere
        noResultsMessage.style.display = (filter !== '' && !hasVisibleItemsOverall) ? 'block' : 'none';
        noResultsMessage.textContent = `No apps found matching "${filter}".`; // Update message text


         // Ensure favorites section visibility is re-checked after filtering,
         // as hiding/showing buttons inside might affect scrollability and arrow visibility.
         // The section's *display* property is controlled by the favoriting script,
         // but filtering can change button visibility *within* it.
         const favSection = document.getElementById('favoritesSection');
         if (favSection) {
             // Call the favorite section's stored visibility update function.
             // This function checks total children, not just visible ones after filter,
             // to decide if the section should be shown/hidden.
             const updateFavVisibility = favSection._updateSectionVisibility;
             if (typeof updateFavVisibility === 'function') {
                 // This function also triggers its own arrow update.
                  requestAnimationFrame(() => setTimeout(updateFavVisibility, 10)); // Delay slightly
             }
         }
      // console.log(`--- Filtering done for: "${filter}" ---`);
    }
    // --- END Search Filter Logic ---


      // --- Item Launch Logic (Adjusted for "Apps") ---
      // This function is primarily used by the favoriting script when it clones buttons
      // to ensure the cloned heart icon can be clicked. The actual app launch
      // for *all* buttons (both original in the main grid and cloned in the favorites section).
      // is handled by the delegated listener on the main container below.
      // This function definition is kept but doesn't perform the launch itself.
      function addItemLaunchListener(button) {
        // console.log("addItemLaunchListener called for:", getButtonName(button)); // DEBUG
        // The delegated listener on the main container handles the click for launching.
        // This function does not add a *new* launch listener here. It's mainly kept
        // as a placeholder if needed by other scripts or for clarity.
      }
      // --- END Item Launch Logic ---

    </script>

    <!-- Favoriting Logic (Self-contained in IIFE) (Adjusted for "Apps" and key format) -->
    <script>
        // --- Favoriting Logic ---
        (() => { // Using an Immediately Invoked Function Expression (IIFE) to keep variables local
            let favoriteContainer = null;
            let favoritesSection = null;
            let allButtons = []; // Cache all app buttons (original only)

            // Function to get a button by its game ID (gets the ORIGINAL button from the grid)
            function getOriginalButtonById(itemId) { // Changed parameter name to itemId
                 // Use the cached list, or query the DOM if cache is empty/stale
                 // Cache only buttons from the main grid container
                 allButtons = Array.from(document.querySelectorAll(".btn-container-grid .btn[data-game-id]"));

                 return allButtons.find(btn => btn.dataset.gameId === itemId); // Use itemId
            }


            // Function to show/hide the favorites section based on its content
            function updateFavoritesSectionVisibility() {
                 favoriteContainer = favoriteContainer || document.querySelector("#favoritesSection .favorite-container");
                 favoritesSection = favoritesSection || document.getElementById('favoritesSection');

                 if (!favoriteContainer || !favoritesSection) {
                     console.error("Favoriting script: Favorites container or section not found in updateFavoritesSectionVisibility.");
                     return;
                 }
                 // The section should be visible if it has ANY child buttons
                 const hasAnyFavorites = favoriteContainer.children.length > 0;
                 // Set display property. Use '' to revert to CSS default (which should be flex as per new CSS)
                 favoritesSection.style.display = hasAnyFavorites ? '' : 'none';

                 // Always trigger arrow update if the section *could* be visible
                 if (hasAnyFavorites) {
                     // Use the stored update function, checking it exists
                     const updateFunc = favoritesSection._updateArrowVisibility; // Assumes setupScrollArrows stored it
                     if (typeof updateFunc === 'function') {
                          // Use rAF + setTimeout for robust post-layout update after display potentially changes
                          requestAnimationFrame(() => setTimeout(updateFunc, 10));
                     }
                 }
                 // console.log(`Favoriting script: Favorites section visibility updated. Has favorites: ${hasAnyFavorites ? 'Yes (' + favoriteContainer.children.length + ' items)' : 'No'}. Display: ${favoritesSection.style.display}`); // Debug
            }
            // Store the visibility update function on the element for other scripts (like filterApps)
            // This allows filterApps to trigger a re-check after hiding/showing buttons within it due to search.
            // This assignment should happen AFTER DOMContentLoaded when the element is guaranteed to exist.
            // It's moved to the DOMContentLoaded block below.


            // Handles the click event specifically on the heart icon
            function handleHeartIconClick(event) {
                event.stopPropagation(); // Prevent the parent button's click event (for launching) from firing
                const heartIcon = event.currentTarget; // The icon element itself
                const button = heartIcon.closest(".btn"); // The parent button
                if (!button) {
                     console.error("Favoriting script: Heart icon click: Could not find parent button.");
                     return;
                }
                 // console.log("Favoriting script: Heart icon clicked for:", getButtonName(button)); // Debug

                toggleFavoriteState(button); // Pass the button element to toggle its state
            }

            // Toggles the hearted class, updates localStorage, and manages the Favorites section
             function toggleFavoriteState(button) {
                 const heartIcon = button.querySelector('.heart-icon');
                 if (!heartIcon) {
                     console.error("Favoriting script: Toggle state: Heart icon not found on button.");
                     return;
                 }

                 // Get or generate a stable unique ID for the item based on its path
                 let itemId = button.dataset.gameId;
                 if (!itemId) {
                     const itemPath = button.getAttribute("data-path");
                     // Generate a safe, unique ID from the path
                     // This ID format must be consistent with how IDs are saved/retrieved in localStorage
                     // Add a prefix like 'app-' to differentiate from game IDs if needed in the future
                     itemId = itemPath ? `app-fav-${itemPath.replace(/[^a-zA-Z0-9]+/g, '-')}` : `app-fav-unknown-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                     button.dataset.gameId = itemId; // Add the generated ID to the button
                     console.warn(`Favoriting script: Generated missing data-game-id: ${itemId} for path: ${itemPath}`); // Warn if ID was missing
                 }

                 // Use a consistent key format for localStorage across different pages (apps/games)
                 const localStorageKey = `heartState-${itemId}`;
                 // console.log(`Favoriting script: Toggling state for ID: ${itemId}, localStorage key: ${localStorageKey}`); // Debug

                 const isCurrentlyHearted = heartIcon.classList.contains("hearted");
                 // Select ALL buttons with this unique ID on the page (original list + favorites list)
                 // This is needed to sync the heart state across both potentially existing buttons
                 const allMatchingButtons = document.querySelectorAll(`.btn[data-game-id="${itemId}"]`);

                 if (isCurrentlyHearted) {
                     // Item was favorited, now unfavoriting
                     console.log(`Favoriting script: Unfavoriting: ${itemId}`); // Debug
                     // Remove 'hearted' class from all buttons representing this item
                     allMatchingButtons.forEach(btn => btn.querySelector('.heart-icon')?.classList.remove("hearted"));
                     // Update state in localStorage
                     localStorage.setItem(localStorageKey, "false"); // Explicitly save as false
                     // Remove the item from the favorites section
                     removeFromFavorites(itemId);
                 } else {
                     // Item was not hearted, now favoriting
                     console.log(`Favoriting script: Favoriting: ${itemId}`); // Debug
                      // Add 'hearted' class to all buttons representing this item
                     allMatchingButtons.forEach(btn => btn.querySelector('.heart-icon')?.classList.add("hearted"));
                     // Update state in localStorage
                     localStorage.setItem(localStorageKey, "true"); // Explicitly save as true
                     // Add the item to the favorites section.
                     // We need the original button from the main grid to clone from.
                     const originalButton = getOriginalButtonById(itemId);
                      // console.log("Favoriting script: Original button found for adding:", originalButton); // Debug
                     if (originalButton) {
                         addToFavorites(originalButton); // Add to the favorites section
                     } else {
                          console.warn(`Favoriting script: Original button with data-game-id="${itemId}" not found outside main grid (.btn-container-grid). Cannot clone for favorites.`); // Should not happen if logic is correct
                          // If original wasn't found but we are favoriting, it implies the button might
                          // already be in the favorites section but lost its state or listener?
                          // In this case, just ensure visibility/arrows are correct.
                           updateFavoritesSectionVisibility();
                     }
                 }
                 // After toggling state, trigger a filter update to ensure visibility is correct
                 // This handles cases where the filter might hide unfavorited items immediately
                 // Use rAF + setTimeout for robust re-filter after DOM changes
                  requestAnimationFrame(() => setTimeout(filterApps, 10));
             }

             // Adds a cloned version of the button to the favorites container
             function addToFavorites(originalButton) {
                 favoriteContainer = favoriteContainer || document.querySelector("#favoritesSection .favorite-container"); // Ensure ref is fresh
                 if (!favoriteContainer) {
                      console.error("Favoriting script: favoriteContainer is null in addToFavorites.");
                      return;
                 }
                 const itemId = originalButton.dataset.gameId;
                 if (!itemId) {
                     console.error("Favoriting script: Cannot add to favorites: original button missing data-game-id.");
                     return;
                 }
                 // Check if a favorite button with this ID already exists in the favorites container
                 const existingFavorite = favoriteContainer.querySelector(`.btn[data-game-id="${itemId}"]`);

                 if (!existingFavorite) {
                     console.log(`Favoriting script: Cloning and adding to favorites: ${itemId}`); // Debug
                     // Clone the button and all its child nodes
                     const clonedButton = originalButton.cloneNode(true);

                     // Ensure the cloned heart icon has the 'hearted' class (state should be set by toggleFavoriteState already)
                     const clonedHeartIcon = clonedButton.querySelector('.heart-icon');
                     if (clonedHeartIcon) {
                         clonedHeartIcon.classList.add('hearted'); // Ensure red heart
                         // *** IMPORTANT: Re-add the click listener to the heart icon on the CLONED button ***
                         // The delegated listener on the main container handles the *launch* click for clones,
                         // but the *heart toggle* needs a listener directly on the icon itself.
                         clonedHeartIcon.removeEventListener('click', handleHeartIconClick); // Remove potential old listener
                         clonedHeartIcon.addEventListener('click', handleHeartIconClick);
                     } else {
                          console.error("Favoriting script: Cloned button missing heart icon:", clonedButton); // Debug
                     }

                     // Remove any 'hidden' class the filter might have applied
                     clonedButton.classList.remove('hidden');

                     // Add the cloned button to the favorites container
                     favoriteContainer.appendChild(clonedButton);
                     console.log(`Favoriting script: Successfully added clone of ${itemId} to favorites.`); // Debug
                 } else {
                     console.log(`Favoriting script: Item ${itemId} already exists in favorites container. Ensuring visible.`); // Debug
                     // If it already exists, just ensure its heart icon is red (should be already)
                     existingFavorite.querySelector('.heart-icon')?.classList.add('hearted');
                     // Ensure it's not hidden by the filter if it was previously hidden
                     existingFavorite.classList.remove('hidden');
                 }

                 // Update the visibility and scroll arrows of the favorites section
                 updateFavoritesSectionVisibility();
             }

             // Removes the button with the given ID from the favorites container
             function removeFromFavorites(itemId) {
                 favoriteContainer = favoriteContainer || document.querySelector("#favoritesSection .favorite-container"); // Ensure ref is fresh
                 if (!favoriteContainer) {
                     console.error("Favoriting script: favoriteContainer is null in removeFromFavorites.");
                     return;
                 }
                 // Find the button specifically within the favorites container using its ID
                 const favoritedItem = favoriteContainer.querySelector(`.btn[data-game-id="${itemId}"]`);
                  console.log(`Favoriting script: Attempting to remove ${itemId} from favorites. Found element:`, favoritedItem); // Debug
                 if (favoritedItem) {
                      // Remove the heart click listener before removing the element (good practice)
                      const heartIcon = favoritedItem.querySelector('.heart-icon');
                      if (heartIcon) heartIcon.removeEventListener('click', handleHeartIconClick);
                     // Remove the button element from the DOM
                     favoritedItem.remove(); // .remove() is a modern way to remove an element
                     console.log(`Favoriting script: Successfully removed ${itemId} from favorites.`); // Debug
                 } else {
                     console.warn(`Favoriting script: Could not find ${itemId} in favorites container to remove.`); // Debug
                 }
                 // Update the visibility and scroll arrows of the favorites section
                 updateFavoritesSectionVisibility();
             }


            // --- Initialization Logic (Runs when DOM is ready) ---
            document.addEventListener("DOMContentLoaded", function() {
                 console.log("Favoriting script: DOMContentLoaded.");

                 favoriteContainer = document.querySelector("#favoritesSection .favorite-container");
                 favoritesSection = document.getElementById('favoritesSection');

                 if (!favoriteContainer || !favoritesSection) {
                     console.error("Favoriting script initialization failed: Favorites container or section not found."); // Debug missing elements
                     return; // Stop if essential elements are missing
                 }
                 // Store the visibility update function on the section element AFTER getting the reference
                 favoritesSection._updateSectionVisibility = updateFavoritesSectionVisibility;


                 // Pass 1: Process all original buttons on the page (those in the main grid)
                 // Ensure we only target buttons in the main grid, not potentially leftover ones in the fav section on reload
                 allButtons = Array.from(document.querySelectorAll(".btn-container-grid .btn[data-path]")); // Cache original buttons
                  console.log(`Favoriting script: Found ${allButtons.length} original buttons in grid.`); // Debug count

                 allButtons.forEach(button => {
                    const heartIcon = button.querySelector(".heart-icon");
                    if (!heartIcon) {
                         console.warn("Favoriting script: Button missing heart icon:", button);
                        return; // Skip buttons without heart icons
                    }

                    // Get or generate a stable unique ID for the item based on its path
                    let itemId = button.dataset.gameId;
                     if (!itemId) {
                         const itemPath = button.getAttribute("data-path");
                          // Generate a safe, unique ID from the path
                         itemId = itemPath ? `app-fav-${itemPath.replace(/[^a-zA-Z0-9]+/g, '-')}` : `app-fav-unknown-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                         button.dataset.gameId = itemId; // Add the generated ID
                         console.warn(`Favoriting script: Generated missing data-game-id: ${itemId} for path: ${itemPath}`);
                     }
                      // console.log(`Favoriting script: Processing original button: ${itemId}`); // Debug

                    // *** Attach the heart click listener to the heart icon on the original button ***
                    // This listener is needed for the initial click on the original button.
                     heartIcon.removeEventListener('click', handleHeartIconClick); // Remove potential old listener
                    heartIcon.addEventListener('click', handleHeartIconClick);

                    // Check localStorage for initial state using the derived key
                    const localStorageKey = `heartState-${itemId}`;
                    const isHearted = localStorage.getItem(localStorageKey) === "true"; // Check specifically for "true" string

                    // Set the 'hearted' class on the original button's heart icon based on saved state
                    if (isHearted) {
                        heartIcon.classList.add("hearted");
                         // console.log(`Favoriting script: Item ${itemId} is favorited in localStorage.`); // Debug
                    } else {
                        heartIcon.classList.remove("hearted");
                        // console.log(`Favoriting script: Item ${itemId} is NOT favorited in localStorage.`); // Debug
                    }
                 });
                  console.log("Favoriting script: Pass 1 (Original buttons in grid) complete.");

                 // Pass 2: Populate Favorites Section based on saved state
                 // Iterate through the cached original buttons again (now they all have data-game-id)
                 allButtons.forEach(button => { // Use the cached allButtons array
                     const itemId = button.dataset.gameId;
                     const localStorageKey = `heartState-${itemId}`;
                     const isHearted = localStorage.getItem(localStorageKey) === "true";

                     // If the item is marked as hearted in localStorage, add it to the favorites section
                     if (isHearted) {
                         // Check again if it's somehow already there (redundancy check, shouldn't happen with fresh DOM)
                          if (!favoriteContainer.querySelector(`.btn[data-game-id="${itemId}"]`)) {
                              console.log(`Favoriting script: Populating favorites: Adding ${itemId} from saved state.`); // Debug
                              // addToFavorites handles cloning and listener for the cloned heart icon
                              addToFavorites(button);
                          } else {
                              // This case might happen on reload if the browser cached content before JS runs,
                              // or if there's an issue clearing the fav container. Ensure it's visible and hearted.
                              const existingFavButton = favoriteContainer.querySelector(`.btn[data-game-id="${itemId}"]`);
                              if(existingFavButton) {
                                   existingFavButton.classList.remove('hidden');
                                   existingFavButton.querySelector('.heart-icon')?.classList.add('hearted');
                                   // Also re-add the click listener just in case (e.g., element was dynamically added without it)
                                    const heartIcon = existingFavButton.querySelector('.heart-icon');
                                    if (heartIcon) {
                                        heartIcon.removeEventListener('click', handleHeartIconClick);
                                        heartIcon.addEventListener('click', handleHeartIconClick);
                                    }
                              }
                              console.log(`Favoriting script: Populating favorites: ${itemId} already present. Ensured visible and hearted.`); // Debug
                          }
                     }
                 });
                  console.log("Favoriting script: Pass 2 (Populating favorites) complete.");

                 // Final step: Update the visibility of the favorites section based on populated items
                 updateFavoritesSectionVisibility();
                  console.log("Favoriting script initialization complete.");
            });
        })(); // Immediately invoke the IIFE
        // --- END Favoriting Logic ---
    </script>


    <!-- Main Initializer (Runs on DOMContentLoaded) -->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
          console.log("Main Initializer: DOM Loaded. Initializing Apps page logic...");

           // NOTE: Favoriting logic runs *within* its own DOMContentLoaded listener
           // and populates the favorites section *before* this script continues
           // beyond its initial setup. This is good.

          // 1. Get Element References (Including Settings Elements)
          customCursor = document.getElementById('custom-cursor');
          navLinks = document.querySelectorAll('.nav-link');
          body = document.body;
          unfocusedOverlay = document.getElementById('unfocused-overlay'); // Get reference here

          // Settings menu element references
          settingsPanel = document.getElementById('settings');
          settingsOverlay = document.getElementById('settings-overlay');
          settingsToggleLink = document.getElementById('settings-toggle-link');
          animationsButton = document.getElementById('animations-button');
          particlesButton = document.getElementById('particles-button');
          particlesLinesButton = document.getElementById('particles-lines-button');
          movingPhrasesButton = document.getElementById('moving-phrases-button');
          performanceCursorButton = document.getElementById('performance-cursor-button');
          resetSettingsBtn = document.getElementById('reset-settings-btn');
          overlayColorButtonList = document.querySelector('#settings .color-button-list[data-setting="overlay"]');
          cursorBorderColorButtonList = document.querySelector('#settings .color-button-list[data-setting="cursor-border"]');
          cursorHoverColorButtonList = document.querySelector('#settings .color-button-list[data-setting="cursor-hover"]');
          sneakModeSelect = document.getElementById('sneak-mode-select'); // Get reference here
          themeSelect = document.getElementById('theme-select'); // Get reference here
          // *** ASSIGN ELEMENT REFERENCES HERE ***
          openBlankButton = document.getElementById('open-blank-button'); // Assign reference
          enableCursorButton = document.getElementById('enable-cursor-button'); // Assign reference


           // Check if essential settings elements are found
          if (!settingsPanel || !settingsOverlay || !settingsToggleLink || !unfocusedOverlay || !sneakModeSelect) {
              console.error("Main Initializer: Critical UI elements for settings menu or sneak mode are missing. These features may not function.");
              // Disable settings link or handle gracefully if elements are missing
              if (settingsToggleLink) settingsToggleLink.style.display = 'none'; // Hide the link

               // Log which elements are missing for easier debugging
               if (!settingsPanel) console.error("#settings element missing.");
               if (!settingsOverlay) console.error("#settings-overlay element missing.");
               if (!settingsToggleLink) console.error("#settings-toggle-link element missing.");
               if (!unfocusedOverlay) console.error("#unfocused-overlay missing.");
               if (!sneakModeSelect) console.error("#sneak-mode-select missing.");

              // Continue initialization but settings-related functions might fail
          } else {
               console.log("Main Initializer: Settings menu and sneak mode elements found.");
          }

           // Get reference to the main content area
           mainContainer = document.querySelector('main.hub-container');
            if (!mainContainer) console.error("Main Initializer: main.hub-container not found.");


          // 2. Setup Scroll Arrows for ALL categories
          // This needs to run *after* the DOM is fully loaded and potentially populated by
          // other scripts like the favoriting logic.
          try {
              console.log("Main Initializer: Setting up scroll arrows for all categories...");
               // Select only horizontal scrolling categories (those with .favorite-container for now)
              document.querySelectorAll('.game-category').forEach(category => {
                   // Only run setup if the category contains a .favorite-container (horizontal)
                  if (category.querySelector('.favorite-container')) {
                       setupScrollArrows(category);
                   } else {
                       // Hide arrows if the category *has* arrow elements but is not a favorite container
                       const leftArrow = category.querySelector('.scroll-arrow.left-arrow');
                       const rightArrow = category.querySelector('.scroll-arrow.right-arrow');
                       if (leftArrow) leftArrow.style.display = 'none';
                       if (rightArrow) rightArrow.style.display = 'none';
                   }
              });
              console.log("Main Initializer: Scroll arrow setup complete.");
          } catch (error) {
              console.error("Main Initializer: Error setting up scroll arrows:", error);
          }


          // 3. Attach Delegated Item Launch Listener (Adjusted for "Apps")
          // This single listener on the main container handles clicks for *all* buttons
          // (both original in the main grid and cloned in the favorites section).
          try {
              mainContainer = mainContainer || document.querySelector('main.hub-container'); // Ensure ref fresh
              if (mainContainer) {
                  console.log("Main Initializer: Attaching delegated item launch listener to main.hub-container");
                   // Remove existing listener to prevent duplicates
                  if (mainContainer._launchListener) {
                      mainContainer.removeEventListener('click', mainContainer._launchListener);
                  }

                  const launchListener = function(event) {
                      // Find the closest ancestor element that is a button with class 'btn' and has a data-path
                      const clickedButton = event.target.closest('.btn[data-path]');
                      if (!clickedButton) {
                          // console.log("Delegated listener: Clicked element is not a button with data-path."); // Debug non-button clicks
                          return; // Clicked outside an item button
                      }

                      // Check if the click originated from the heart icon *within* the button
                      // This prevents launching the app when trying to favorite/unfavorite
                      // We check for the icon element itself or any ancestor that is the icon (like its SVG content)
                      const heartIcon = clickedButton.querySelector('.heart-icon');
                      if (heartIcon && (event.target === heartIcon || heartIcon.contains(event.target))) {
                         console.log("Delegated listener: Heart click detected, stopping app launch.");
                         // The handleHeartIconClick listener (attached directly to heart icons)
                         // will handle the favoriting logic and uses stopPropagation().
                         // This check here is defensive in case the propagation wasn't stopped correctly.
                         return;
                      }


                      console.log("Delegated listener: Valid button click detected for launching:", clickedButton); // DEBUG

                      const path = clickedButton.getAttribute('data-path');
                      const itemName = getButtonName(clickedButton); // Use the robust helper function

                      // Check if the path is valid and not just a placeholder '#'
                      if (path && path !== '#') {
                        // Path should now be relative to the Apps/ directory (e.g., "Simple Calculator.html")
                        // The game.html loader is *also* in the Apps/ directory, so it needs the path relative to itself.
                        console.log(`LAUNCHING (Delegated): "${itemName}" with path: "${path}".`); // DEBUG
                        // Save details to localStorage so the loader page knows what to load
                        // Save the path *as is* because it's relative to the Apps/ directory,
                        // where the game.html loader also resides.
                        localStorage.setItem("lastClickedUrl", path); // Save path relative to Apps/
                        localStorage.setItem("lastClickedGame", itemName); // Storing app name

                         // Get current settings to check openInBlank
                         const currentSettings = window.getSettings ? window.getSettings() : { openInBlank: 'off' }; // Default settings
                         const openInBlankEnabled = currentSettings.openInBlank === 'on';
                         console.log(`Delegated listener: Open in Blank setting is ${openInBlankEnabled ? 'ON' : 'OFF'}.`);


                         // Decide how to open based on the setting
                         if (openInBlankEnabled) {
                             event.preventDefault(); // Prevent default navigation
                             console.log("Attempting to open app in new about:blank tab.");
                             // Open the loader page in a new tab/window with about:blank initially
                             const newWindow = window.open('about:blank', '_blank', 'noopener,noreferrer');
                             if (newWindow) {
                                  // Redirect the new window to the loader page after it opens
                                  // Use a slight delay to give the new window time to load about:blank
                                  setTimeout(() => {
                                       try {
                                            newWindow.location.href = "./game.html"; // Navigate to game.html within the current (Apps) directory
                                            console.log("Successfully redirected about:blank tab to ./game.html");
                                       } catch (e) {
                                            console.error("Error redirecting about:blank tab:", e);
                                            // Fallback: if redirect fails, try navigating the current window
                                            alert("Failed to open app in new tab. Navigating in the current tab instead.");
                                            window.location.href = "./game.html";
                                       }
                                  }, 50); // Small delay

                             } else {
                                  console.error("Failed to open new window for about:blank launch.");
                                  alert("Failed to open the app. Please check your browser's pop-up blocker settings.");
                                  // Fallback: Try navigating the current window if opening a new one failed
                                   window.location.href = "./game.html";
                             }
                         } else {
                             // Let the default click behavior navigate directly to the loader page
                             // The button is a <button> element, so we need to manually navigate
                             event.preventDefault(); // Prevent default button action
                             console.log("Open in Blank OFF. Navigating directly to ./game.html in current tab.");
                             window.location.href = "./game.html"; // Navigate to game.html within the current (Apps) directory
                         }

                      } else {
                        console.error("Delegated Launch Error: Button missing or has invalid data-path.", clickedButton);
                        alert("Error: Could not determine app details to launch.");
                      }
                  };
                  mainContainer.addEventListener('click', launchListener);
                   mainContainer._launchListener = launchListener; // Store listener reference
                  console.log("Main Initializer: Delegated item launch listener attached.");
              } else {
                   console.error("Main Initializer: Could not find main.hub-container for delegated listener.");
              }
          } catch (error) {
               console.error("Main Initializer: Error attaching delegated item launch listener:", error);
          }


          // 4. Attach Search Listeners (Uses filterApps now)
          try {
              console.log("Main Initializer: Attaching search listeners...");
               searchInput = searchInput || document.getElementById('myInput'); // Ensure ref fresh
               searchIconBtn = searchIconBtn || document.querySelector('.search-icon-btn'); // Ensure ref fresh

              if (searchInput && searchIconBtn) {
                   // Ensure existing listeners are removed before adding
                   if (searchIconBtn._searchClickListener) searchIconBtn.removeEventListener('click', searchIconBtn._searchClickListener);
                   if (searchInput._keypressListener) searchInput.removeEventListener('keypress', searchInput._keypressListener);
                   if (searchInput._inputListener) searchInput.removeEventListener('input', searchInput._inputListener);


                   // Clicking the icon focuses the input and performs filter
                   const searchClickListener = () => {
                     searchInput.focus();
                     filterApps(); // Call the updated function
                   };
                    searchIconBtn.addEventListener('click', searchClickListener);
                    searchIconBtn._searchClickListener = searchClickListener;


                   // Pressing Enter in the input performs filter
                   const keypressListener = function(event) {
                     if (event.key === 'Enter') {
                       event.preventDefault(); // Prevent form submission if input was in a form
                       filterApps(); // Call the updated function
                     }
                   };
                   searchInput.addEventListener('keypress', keypressListener);
                   searchInput._keypressListener = keypressListener;


                   // Debounce keyup/input for better performance as user types
                   // Use 'input' event which covers keypress, paste, clear button etc.
                    const inputListener = debounce(filterApps, 250);
                   searchInput.addEventListener('input', inputListener);
                    searchInput._inputListener = inputListener;

                   console.log("Main Initializer: Search listeners attached.");
               } else {
                  console.error("Main Initializer: Search input (#myInput) or button (.search-icon-btn) not found.");
               }

              // 5. Initial Filter on Load (if search has a value from browser history/refresh)
              // Perform this check *after* favoriting script might have added/removed elements
              // and after scroll arrows are setup (as filter calls updateArrowVisibility).
              // Add a small delay using rAF for robustness
              requestAnimationFrame(() => {
                   searchInput = searchInput || document.getElementById('myInput'); // Ensure ref fresh
                   if (searchInput && searchInput.value.trim() !== '') {
                     console.log("Main Initializer: Performing initial filter based on input value.");
                     filterApps(); // Call the updated function
                   } else {
                      console.log("Main Initializer: No initial search value, skipping filter.");
                      // If no filter, manually trigger arrow updates for all *horizontal* categories
                      // (Favorites section, if visible)
                       document.querySelectorAll('.game-category .favorite-container').forEach(container => {
                            const category = container.closest('.game-category');
                             if (category && typeof category._updateArrowVisibility === 'function') {
                                  category._updateArrowVisibility();
                             }
                       });
                   }
              });
          } catch (error) {
               console.error("Main Initializer: Error attaching search listeners or performing initial filter:", error);
          }


          // --- Settings Side Menu Listeners and Initial State ---

          // 6. Attach Listener for the Settings Toggle Link in the Header
          settingsToggleLink = settingsToggleLink || document.getElementById('settings-toggle-link'); // Ensure ref fresh
          if (settingsToggleLink) {
              // Ensure only one listener is attached
              if (settingsToggleLink._toggleListener) {
                  settingsToggleLink.removeEventListener('click', settingsToggleLink._toggleListener);
              }
              const toggleListener = (event) => {
                  // Prevent default anchor link behavior. The link just toggles the menu, it doesn't navigate.
                  event.preventDefault();
                  console.log("Main Initializer: Clicked Settings toggle link. Toggling menu."); // Debug click
                  toggleSettingsMenu(); // Simply toggle the menu state
                   // We are intentionally NOT changing the URL hash here when clicking the toggle link.
              };
              settingsToggleLink.addEventListener('click', toggleListener);
              settingsToggleLink._toggleListener = toggleListener; // Store listener reference
               // Set initial aria-expanded state (will be updated by toggleSettingsMenu when called)
              settingsToggleLink.setAttribute('aria-expanded', 'false');
          }

          // 7. Attach Listener for the Settings Overlay to close the menu
          settingsOverlay = settingsOverlay || document.getElementById('settings-overlay'); // Ensure ref fresh
          if (settingsOverlay) {
               // Ensure only one listener is attached
              if (settingsOverlay._closeListener) {
                  settingsOverlay.removeEventListener('click', settingsOverlay._closeListener);
              }
              const closeListener = () => {
                  console.log("Main Initializer: Clicked settings overlay. Closing menu."); // Debug click
                  toggleSettingsMenu(false); // Close the menu when clicking the overlay
                  // If the URL hash is currently #settings (e.g. manual navigation), change it back
                   if (window.location.hash === '#settings') {
                       // On apps page, just remove the hash
                       history.replaceState(null, '', window.location.pathname + window.location.search);
                       // hashchange doesn't fire for replaceState, toggleSettingsMenu(false) already calls updateNavActiveState
                   }
                   hashThatOpenedSettings = null; // Reset flag
              };
              settingsOverlay.addEventListener('click', closeListener);
              settingsOverlay._closeListener = closeListener; // Store listener reference
          }


           // 8. Attach Listeners for Settings Buttons (Toggles), Color Pickers, and Select
           // *** ENSURE THESE REFERENCES ARE ASSIGNED IN STEP 1 ***
           // Added checks before calling setup functions
           if (animationsButton) setupButtonToggle(animationsButton, 'enableAnimations');
           if (particlesButton) setupButtonToggle(particlesButton, 'showParticles');
           if (particlesLinesButton) setupButtonToggle(particlesLinesButton, 'showParticlesLines');
            // The moving phrases button exists in HTML but should be disabled/ignored on this page
           if (movingPhrasesButton) {
              movingPhrasesButton.disabled = true;
              movingPhrasesButton.title = "This setting is only available on the Home page.";
              // Do NOT call setupButtonToggle for movingPhrasesButton on this page
           }

           if (performanceCursorButton) setupButtonToggle(performanceCursorButton, 'performanceCursorOn');
           if (openBlankButton) setupButtonToggle(openBlankButton, 'openInBlank'); // Setup listener for Open in Blank button
           if (enableCursorButton) setupButtonToggle(enableCursorButton, 'enableCustomCursor'); // Setup listener for Enable Cursor button


           if (overlayColorButtonList) setupColorButtonList(overlayColorButtonList, 'overlayColor');
           if (cursorBorderColorButtonList) setupColorButtonList(cursorBorderColorButtonList, 'cursorColor');
           if (cursorHoverColorButtonList) setupColorButtonList(cursorHoverColorButtonList, 'cursorHoverColor');

           // Setup listener for the Sneak Mode Select
           if (sneakModeSelect) setupSelectListener(sneakModeSelect, 'sneakModeApp');


           // Theme select is always dark/disabled for now - just ensure initial state
           if (themeSelect) {
             themeSelect.value = 'dark';
             themeSelect.disabled = true;
             themeSelect.title = "Currently only Dark theme is available.";
           }


           // 9. Attach Listener for Reset Button
           resetSettingsBtn = resetSettingsBtn || document.getElementById('reset-settings-btn'); // Ensure ref fresh
           if (resetSettingsBtn && typeof window.clearSettings === 'function') {
                if (resetSettingsBtn._resetListener) {
                    resetSettingsBtn.removeEventListener('click', resetSettingsBtn._resetListener);
                }
               const resetListener = function() {
                  console.log("Main Initializer: Resetting settings...");
                  window.clearSettings(); // clearSettings calls applySettings which dispatches events
                  alert('Settings reset to default!'); // User feedback
                   // Optionally, close the settings menu after reset
                   // toggleSettingsMenu(false); // Decide if reset should close the menu
               };
               resetSettingsBtn.addEventListener('click', resetListener);
               resetSettingsBtn._resetListener = resetListener;
           } else if (resetSettingsBtn) {
               console.warn("Main Initializer: #reset-settings-btn found, but clearSettings function not available. Cannot setup reset listener.");
           } else {
               console.warn("Main Initializer: #reset-settings-btn not found.");
           }


           // 10. Listen for the globalSettingsApplied event from globalSettings.js
            // This event is fired when settings are loaded and applied initially,
            // and also when settings are saved or reset.
            body = body || document.body; // Ensure ref fresh
            if (body && body._settingsAppliedListener) {
                body.removeEventListener('globalSettingsApplied', body._settingsAppliedListener);
            }
            const settingsAppliedListener = (event) => {
              console.log("Apps page received globalSettingsApplied event.", event.detail.settings);
              // Update settings UI state based on new settings (includes active color buttons, button text, select value)
              updateSettingsUIFromLoadedSettings();

              // Re-apply page state affected by settings:
               requestAnimationFrame(() => {
                    // Re-run filter (handles showing/hiding based on animations + search)
                    // Pass the current search value explicitly
                    filterApps();
                    // Ensure favorites section state is correct (visibility and arrow updates)
                    const favSection = document.getElementById('favoritesSection');
                    if (favSection && typeof favSection._updateSectionVisibility === 'function') {
                         favSection._updateSectionVisibility();
                    }
               });


               // Ensure interactive cursor listeners are updated as elements might have changed state/appearance
               addInteractiveCursorListeners();

                // Sneak mode handling is now done within globalSettings.js applySettings
                // which calls enable/disableSneakMode.

            };
            if (body) {
                 body.addEventListener('globalSettingsApplied', settingsAppliedListener);
                 body._settingsAppliedListener = settingsAppliedListener; // Store listener
            } else {
                console.error("Main Initializer: Cannot attach globalSettingsApplied listener, body element not found.");
            }


            // 11. Listen for globalSettingsReset event
            body = body || document.body; // Ensure ref fresh
            if (body && body._settingsResetListener) {
                body.removeEventListener('globalSettingsReset', body._settingsResetListener);
            }
            const settingsResetListener = () => {
               console.log("Apps page received globalSettingsReset event.");
                // No specific Apps page state (like typing) to reset here, unlike index.html.
                // The globalSettingsApplied listener (triggered by clearSettings) handles updating UI and re-applying general settings.
            };
             if (body) {
                 body.addEventListener('globalSettingsReset', settingsResetListener);
                  body._settingsResetListener = settingsResetListener;
             } else {
                console.error("Main Initializer: Cannot attach globalSettingsReset listener, body element not found.");
             }


          // 12. Handle hashchange event (Adapted)
          // This listener primarily manages the opening/closing of the settings menu
          // based on the hash, and updates nav active state.
          window.addEventListener('hashchange', () => {
              const currentHash = window.location.hash;
              console.log("Main Initializer: Hash changed. Current hash:", currentHash, "Hash that opened settings:", hashThatOpenedSettings);

              // If the hash became #settings, open the menu
              if (currentHash === '#settings') {
                  // Only toggle if it wasn't opened by clicking the link (which didn't change hash)
                  // or if it's a direct manual navigation to #settings
                  if (!settingsPanel?.classList.contains('is-visible') || hashThatOpenedSettings !== '#settings') {
                       console.log("Main Initializer: Hash became #settings. Opening settings menu.");
                       toggleSettingsMenu(true);
                       hashThatOpenedSettings = '#settings'; // Mark that a #settings hash triggered the open
                       // updateNavActiveState is called by toggleSettingsMenu(true)
                  } else {
                       console.log("Main Initializer: Hash is #settings but menu is already open, or it was opened by a link click without hash change. No action.");
                  }

              } else {
                  // If the hash changed away from #settings (either manually or via back/forward)
                  if (settingsPanel?.classList.contains('is-visible') && hashThatOpenedSettings === '#settings') {
                       console.log("Main Initializer: Hash changed away from #settings, and menu was opened by #settings hash. Closing settings menu.");
                       toggleSettingsMenu(false); // This will trigger updateNavActiveState for the new hash
                       hashThatOpenedSettings = null; // Reset flag
                  } else {
                       // If hash changed but wasn't #settings related (e.g., #other-section if you had them),
                       // or if the menu wasn't open via #settings hash.
                       // On the Apps page, other hash changes don't switch sections.
                       // Just ensure nav state is correct if settings menu is NOT open.
                        if (!settingsPanel?.classList.contains('is-visible')) {
                             console.log("Main Initializer: Non-#settings hash change, menu not open via #settings. Updating nav state only.");
                            updateNavActiveState(currentHash); // Update nav state for the new hash
                        } else {
                            console.log("Main Initializer: Non-#settings hash change, but settings menu is open. Ignoring hash change for nav state.");
                            // Nav state remains focused on 'Settings' while menu is open
                        }
                  }
              }
          });

           // 13. Attach Click listeners to ALL anchor tags on the page (for Open in Blank setting)
           // Need to handle clicks on <button>s for app launch (delegated listener above)
           // and <a> tags (like header links) for general navigation.
            document.querySelectorAll('a').forEach(link => {
                 // Ensure no duplicate listeners
                 if (link._handleClick) { link.removeEventListener('click', link._handleClick); }

                 const listener = (event) => {
                    const href = link.getAttribute('href');
                    if (!href || href === '#' || href.startsWith('javascript:')) return; // Ignore empty, hash-only, or javascript links

                     // Get current settings
                    const currentSettings = window.getSettings ? window.getSettings() : { openInBlank: 'off' }; // Default settings
                    const openInBlankEnabled = currentSettings.openInBlank === 'on';

                     // Check if it's an external link or a link to a different path on the same origin
                    try {
                       const linkUrl = new URL(href, window.location.href);
                       const currentUrl = new URL(window.location.href);

                       // Check if the link is to the same page, just a different hash (excluding #settings which is handled by hashchange)
                        const isSamePageDifferentHash = linkUrl.origin === currentUrl.origin &&
                                                      linkUrl.pathname === currentUrl.pathname &&
                                                      linkUrl.hash.startsWith('#') &&
                                                      linkUrl.hash !== '' &&
                                                      linkUrl.hash !== window.location.hash &&
                                                      linkUrl.hash !== '#settings';

                       // Check if it's an external or cross-page link (same origin but different path, or different origin)
                       const isExternalOrCrossPageLink = !(linkUrl.origin === currentUrl.origin && linkUrl.pathname === currentUrl.pathname);

                       // Apply "Open in Blank" logic only if the setting is ON AND it's an external/cross-page link
                       if (openInBlankEnabled && isExternalOrCrossPageLink) {
                           console.log(`Link click: Open in Blank ON. Opening external/cross-page link in new tab: ${href}`);
                           event.preventDefault(); // Prevent default navigation
                           window.open(href, '_blank', 'noopener,noreferrer'); // Open in new blank tab
                       } else if (isSamePageDifferentHash) {
                           // Let hashchange handle navigation for same-page hash links (excluding #settings)
                            // This might be redundant as browser default hash change works, but ensures consistency if needed.
                            // For Apps page, other hashes don't do anything visual, so just let the browser handle it or do nothing.
                             // console.log(`Link click: Same page, different hash (${linkUrl.hash}). Letting browser handle.`);
                             // event.preventDefault(); // Decide if you want to prevent default here or not
                             // history.pushState(null, '', linkUrl.hash); // Manually update hash if needed
                       }
                       // For all other links (different same-page hash with setting OFF, or external/cross-page with setting OFF),
                       // let the default browser behavior happen.
                       // Clicks on #settings links are handled by the dedicated settingsToggleLink listener earlier.

                    } catch (e) {
                     console.error("Link click: Error processing link click for:", href, e);
                      // Fallback if URL parsing fails: if openInBlank is ON and href doesn't start with #
                     if (openInBlankEnabled && href && !href.startsWith('#')) {
                        console.warn("Link click: Failed to parse URL, but Open in Blank is ON and href doesn't start with #. Attempting to open in blank as fallback.");
                        event.preventDefault();
                        window.open(href, '_blank', 'noopener,noreferrer');
                     }
                      // If parsing failed and it's a hash link, let the default or hashchange handler take over.
                   }
               };
               link.addEventListener('click', listener);
               link._handleClick = listener; // Store listener reference
            });


          // 14. Initial state setup
          // This needs to happen *after* all element references are grabbed and all listeners are set up.
          // It handles setting the initial menu state and nav active state.
          // A short timeout ensures the DOM is fully processed after DOMContentLoaded.
          setTimeout(() => {
              const initialHash = window.location.hash;
              console.log("Main Initializer: Initial state setup after timeout. Initial Hash:", initialHash);

              // Handle initial settings menu state based on the URL hash
              if (initialHash === '#settings') {
                  console.log("Main Initializer: Initial hash is #settings. Opening settings menu.");
                  toggleSettingsMenu(true);
                  hashThatOpenedSettings = '#settings'; // Mark that #settings hash triggered the open
                   // updateNavActiveState is called by toggleSettingsMenu(true)
              } else {
                  console.log("Main Initializer: Initial hash is not #settings. Ensuring settings menu is closed.");
                  toggleSettingsMenu(false); // Ensure it's closed initially if hash isn't #settings
                  hashThatOpenedSettings = null; // Ensure flag is null
                   // updateNavActiveState is called by toggleSettingsMenu(false)
              }

               // Add interactive cursor listeners initially
               addInteractiveCursorListeners();

               // Manually trigger updateSettingsUIFromLoadedSettings() here
               // The globalSettingsApplied event listener also does this, but calling it explicitly
               // after all page elements and listeners are ready ensures the UI reflects
               // the loaded settings immediately upon full page initialization.
                console.log("Main Initializer: Calling updateSettingsUIFromLoadedSettings for initial UI state.");
               updateSettingsUIFromLoadedSettings();


               // Call updateFavoritesSectionVisibility() once more after everything is set up
               // and populated to ensure its final state is correct based on loaded favorites.
               const favSection = document.getElementById('favoritesSection');
               if (favSection && typeof favSection._updateSectionVisibility === 'function') {
                    console.log("Main Initializer: Calling updateFavoritesSectionVisibility.");
                    favSection._updateSectionVisibility();
               }

               // Trigger an initial filter on load to handle any existing search input or apply animation classes
               // Use rAF for robustness after all elements are potentially rendered and visible state is set
                requestAnimationFrame(() => {
                     console.log("Main Initializer: Triggering initial filter and arrow updates.");
                    filterApps(); // This call also triggers scroll arrow updates for relevant sections
                });


              console.log("Main Initializer: Initialization complete.");
          }, 50); // Small delay (adjust if needed for complex layouts)
      });

        // Helper functions needed by settings UI update (defined here or moved to a shared UI script)
        // These functions are called by updateSettingsUIFromLoadedSettings
        function updateAnimationsButtonText() {
            animationsButton = animationsButton || document.getElementById('animations-button');
            if (animationsButton) animationsButton.textContent = `Animations ${animationsButton.dataset.state === 'on' ? 'ON' : 'OFF'}`;
        }
        function updateParticlesButtonText() {
             particlesButton = particlesButton || document.getElementById('particles-button');
            if (particlesButton) particlesButton.textContent = `Particles ${particlesButton.dataset.state === 'on' ? 'ON' : 'OFF'}`;
        }
        function updateParticlesLinesButtonText() {
             particlesLinesButton = particlesLinesButton || document.getElementById('particles-lines-button');
            if (particlesLinesButton) particlesLinesButton.textContent = `Lines ${particlesLinesButton.dataset.state === 'on' ? 'ON' : 'OFF'}`;
        }
        function updateMovingPhrasesButtonText() {
             movingPhrasesButton = movingPhrasesButton || document.getElementById('moving-phrases-button');
             // This button is disabled on the Apps page, just ensure text is default 'ON'
             if (movingPhrasesButton) movingPhrasesButton.textContent = `Phrases ON`;
        }
        function updatePerformanceCursorButtonText() {
             performanceCursorButton = performanceCursorButton || document.getElementById('performance-cursor-button');
            if (performanceCursorButton) performanceCursorButton.textContent = `Performance ${performanceCursorButton.dataset.state === 'on' ? 'ON' : 'OFF'}`;
        }
         function updateOpenBlankButtonText() {
             openBlankButton = openBlankButton || document.getElementById('open-blank-button');
             if (openBlankButton) openBlankButton.textContent = `Open ${openBlankButton.dataset.state === 'on' ? 'in Blank ON' : 'in Default OFF'}`;
         }
         function updateEnableCursorButtonText() {
             enableCursorButton = enableCursorButton || document.getElementById('enable-cursor-button');
             if (enableCursorButton) enableCursorButton.textContent = `Cursor ${enableCursorButton.dataset.state === 'on' ? 'ON' : 'OFF'}`;
         }


        // Function to setup toggle button listeners (Handles ON/OFF buttons)
        // This function is called *once* during initialization for each toggle button.
        // The settingsApplied event handler updates the button state and text.
        function setupButtonToggle(button, key) {
          // Added check here - if button is null, exit early and log
          if (!button || typeof window.saveSetting !== 'function') {
               console.warn(`setupButtonToggle: Cannot setup listener for key "${key}". Button element invalid or required functions missing. Element found: ${button}`);
               return;
          }

          // Remove existing listener before adding to prevent duplicates
          if (button._buttonToggleListener) {
              button.removeEventListener('click', button._buttonToggleListener);
          }

          const listener = function() {
              const latestSettings = window.getSettings(); // Get the current actual state from settings
              const currentState = latestSettings.hasOwnProperty(key) ? latestSettings[key] : 'off'; // Default to 'off' if not set

              const newState = currentState === 'on' ? 'off' : 'on';

              console.log(`Button click: "${button.id}" (${key}) clicked. Current state from getSettings: "${currentState}". Setting new state: "${newState}"`);
              window.saveSetting(key, newState); // Save the new state globally
               // The globalSettingsApplied event handler will update the UI and apply the setting visually.
          };

          button.addEventListener('click', listener);
          button._buttonToggleListener = listener; // Store listener reference on the element
           // console.log(`setupButtonToggle: Listener added to #${button.id} for key "${key}".`); // Debug setup
        }

        // Function to setup color button list listeners (Handles color pickers)
        // This function is called *once* during initialization for each color list.
        // The settingsApplied event handler updates the 'active' class.
        function setupColorButtonList(list, settingKey) {
            // Added check here - if list is null, exit early and log
            if (!list || typeof window.saveSetting !== 'function') {
                 console.warn(`setupColorButtonList: Color list element (setting: ${settingKey}) invalid or saveSetting function missing. Element found: ${list}`);
                 return;
            }

             // Remove existing listeners from *all* buttons in the list before adding
             list.querySelectorAll('.settings-color-button').forEach(button => {
                  if (button._colorButtonListener) {
                      button.removeEventListener('click', button._colorButtonListener);
                  }
             });

            list.querySelectorAll('.settings-color-button').forEach(button => {
              const listener = function() {
                const selectedColor = this.dataset.color;
                if (selectedColor !== undefined && selectedColor !== null) { // Check for existence
                   console.log(`Color button click: Color setting "${settingKey}" selected: ${selectedColor}`);
                   window.saveSetting(settingKey, selectedColor); // Save the selected color globally
                   // The globalSettingsApplied event handler will update the UI (active class).
                } else {
                   console.warn(`Color button missing data-color attribute for setting "${settingKey}".`);
                }
              };
              button.addEventListener('click', listener);
              button._colorButtonListener = listener; // Store listener reference on the button
            });
             // console.log(`setupColorButtonList: Setup listeners for all color buttons in list for setting "${settingKey}".`); // Debug setup
        }

        // Function to setup select listener
        // This function is called *once* during initialization for the select element.
        // The settingsApplied event handler updates the selected value.
        function setupSelectListener(selectElement, key) {
            // Added check here - if selectElement is null, exit early and log
            if (!selectElement || typeof window.saveSetting !== 'function') {
                 console.warn(`setupSelectListener: Cannot setup listener for key "${key}". Select element invalid or saveSetting function missing. Element found: ${selectElement}`);
                 return;
            }

            // Remove existing listener before adding to prevent duplicates
             if (selectElement._selectChangeListener) {
                 selectElement.removeEventListener('change', selectElement._selectChangeListener);
             }


            const listener = function() {
                const selectedValue = this.value;
                 console.log(`Select change: Setting "${key}" selected value: ${selectedValue}`);
                window.saveSetting(key, selectedValue); // Save the new value globally
                 // The globalSettingsApplied event handler will update the UI (selected value).
            };

            selectElement.addEventListener('change', listener);
            selectElement._selectChangeListener = listener; // Store listener reference on the element
             // console.log(`setupSelectListener: Listener added to #${selectElement.id} for key "${key}".`); // Debug setup
        }


        // This function updates the UI elements in the settings panel based on current settings.
        // It is called when global settings are initially loaded or when they change.
        function updateSettingsUIFromLoadedSettings() {
          // Check if global settings functions are available
          if (typeof window.getSettings !== 'function') {
              console.warn("updateSettingsUIFromLoadedSettings called before globalSettings.js is ready."); // Debug readiness
              return;
          }
          const currentSettings = window.getSettings();
          // console.log("Updating Settings UI from loaded settings:", currentSettings); // Debug loaded settings

          // Re-fetch references just in case (defensive) - though ideally they are assigned in DOMContentLoaded
           animationsButton = animationsButton || document.getElementById('animations-button');
           particlesButton = particlesButton || document.getElementById('particles-button');
           particlesLinesButton = particlesLinesButton || document.getElementById('particles-lines-button');
           movingPhrasesButton = movingPhrasesButton || document.getElementById('moving-phrases-button');
           performanceCursorButton = performanceCursorButton || document.getElementById('performance-cursor-button');
           openBlankButton = openBlankButton || document.getElementById('open-blank-button');
           enableCursorButton = enableCursorButton || document.getElementById('enable-cursor-button');
           resetSettingsBtn = resetSettingsBtn || document.getElementById('reset-settings-btn');
           overlayColorButtonList = overlayColorButtonList || document.querySelector('#settings .color-button-list[data-setting="overlay"]');
           cursorBorderColorButtonList = cursorBorderColorButtonList || document.querySelector('#settings .color-button-list[data-setting="cursor-border"]');
           cursorHoverColorButtonList = cursorHoverColorButtonList || document.querySelector('#settings .color-button-list[data-setting="cursor-hover"]');
           sneakModeSelect = sneakModeSelect || document.getElementById('sneak-mode-select');
           themeSelect = themeSelect || document.getElementById('theme-select');


          // Update ON/OFF button states and text
          if (animationsButton && currentSettings.hasOwnProperty('enableAnimations')) {
              animationsButton.dataset.state = currentSettings.enableAnimations;
              updateAnimationsButtonText();
          } else if (animationsButton) { console.warn("updateSettingsUIFromLoadedSettings: 'enableAnimations' setting missing."); }

          if (particlesButton && currentSettings.hasOwnProperty('showParticles')) {
              particlesButton.dataset.state = currentSettings.showParticles;
              updateParticlesButtonText();
          } else if (particlesButton) { console.warn("updateSettingsUIFromLoadedSettings: 'showParticles' setting missing."); }

           // Update Particles Lines button state and text based on particles state
          if (particlesLinesButton && currentSettings.hasOwnProperty('showParticlesLines') && currentSettings.hasOwnProperty('showParticles')) {
              particlesLinesButton.dataset.state = currentSettings.showParticlesLines;
              updateParticlesLinesButtonText();
              // Add descriptive title based on particles state
               if(currentSettings.showParticles === 'off') {
                    particlesLinesButton.title = "Requires Background Particles to be ON.";
                    particlesLinesButton.disabled = true;
               } else {
                    particlesLinesButton.title = "Toggles lines. The visual effect might require a brief re-render of particles.";
                    particlesLinesButton.disabled = false;
               }
          } else if (particlesLinesButton) { console.warn("updateSettingsUIFromLoadedSettings: 'showParticlesLines' or 'showParticles' setting missing for #particles-lines-button."); }

           // Moving phrases button is disabled on Apps page
          if (movingPhrasesButton && currentSettings.hasOwnProperty('showMovingPhrases')) {
              movingPhrasesButton.dataset.state = currentSettings.showMovingPhrases; // Keep state in dataset but visually disabled
              updateMovingPhrasesButtonText(); // Update to static text
              movingPhrasesButton.disabled = true; // Ensure it's disabled
              movingPhrasesButton.title = "This setting is only available on the Home page."; // Set disabled title
          } else if (movingPhrasesButton) { console.warn("updateSettingsUIFromLoadedSettings: 'showMovingPhrases' setting missing for #moving-phrases-button."); }


          if (performanceCursorButton && currentSettings.hasOwnProperty('performanceCursorOn')) {
              performanceCursorButton.dataset.state = currentSettings.performanceCursorOn;
              updatePerformanceCursorButtonText();
          } else if (performanceCursorButton) { console.warn("updateSettingsUIFromLoadedSettings: 'performanceCursorOn' setting missing."); }

          if (openBlankButton && currentSettings.hasOwnProperty('openInBlank')) {
             openBlankButton.dataset.state = currentSettings.openInBlank;
             updateOpenBlankButtonText();
          } else if (openBlankButton) { console.warn("updateSettingsUIFromLoadedSettings: 'openInBlank' setting missing for #open-blank-button."); }

          if (enableCursorButton && currentSettings.hasOwnProperty('enableCustomCursor')) {
             enableCursorButton.dataset.state = currentSettings.enableCustomCursor;
             updateEnableCursorButtonText();
             // Also update the body class directly here for immediate effect
             body = body || document.body; // Ensure ref fresh
             if (body) {
                 if (currentSettings.enableCustomCursor === 'on') {
                      body.classList.add('custom-cursor-enabled');
                 } else {
                      body.classList.remove('custom-cursor-enabled');
                 }
             }
          } else if (enableCursorButton) { console.warn("updateSettingsUIFromLoadedSettings: 'enableCustomCursor' setting missing for #enable-cursor-button."); }


          // Theme select is always dark/disabled for now
          if (themeSelect) {
            themeSelect.value = 'dark';
            themeSelect.disabled = true;
            themeSelect.title = "Currently only Dark theme is available.";
          } else { console.warn("updateSettingsUIFromLoadedSettings: Theme select element not found."); }

           // --- Sneak Mode Select ---
           if (sneakModeSelect && currentSettings.hasOwnProperty('sneakModeApp')) {
               let valueToSet = currentSettings.sneakModeApp;
               // Check if the value from settings is a valid option in the select dropdown
               const optionExists = Array.from(sneakModeSelect.options).some(option => option.value === valueToSet);

               if (!optionExists) {
                   console.warn(`updateSettingsUIFromLoadedSettings: Loaded sneakModeApp value "${valueToSet}" does not match any option in the select. Defaulting select UI to "off".`);
                   valueToSet = 'off'; // Default the UI select element value
               }
               sneakModeSelect.value = valueToSet; // Set the selected option in the UI
                // console.log(`updateSettingsUIFromLoadedSettings: Set #sneak-mode-select value to "${sneakModeSelect.value}"`);

               // The actual sneak mode listener/overlay state is managed by applySettings in globalSettings.js
               // which calls enable/disableSneakMode.
           } else if (sneakModeSelect) {
                console.warn("updateSettingsUIFromLoadedSettings: 'sneakModeApp' setting not found in currentSettings. Cannot update sneak mode select UI.");
           } else { console.warn("updateSettingsUIFromLoadedSettings: Sneak mode select element not found."); }


          // Update Color Button selections
          const colorLists = [
            { list: overlayColorButtonList, settingKey: 'overlayColor' },
            { list: cursorBorderColorButtonList, settingKey: 'cursorColor' },
            { list: cursorHoverColorButtonList, settingKey: 'cursorHoverColor' }
          ];

          colorLists.forEach(({ list, settingKey }) => {
            if (!list) {
                 console.warn(`Color list element for setting "${settingKey}" not found during UI update.`);
                 return; // Skip if list element is missing
            }
            const currentColor = currentSettings[settingKey];
            // Remove active class from all buttons in the list
            list.querySelectorAll('.settings-color-button').forEach(button => {
              button.classList.remove('active');
            });
            // Add active class to the button matching the current color setting
            if (currentColor !== undefined && currentColor !== null) { // Check for existence, including falsy values if applicable
               // Normalize color string for comparison (handle rgba vs hex, case, spaces)
               const normalizedCurrentColor = typeof currentColor === 'string' ? currentColor.toUpperCase().replace(/\s/g, '') : String(currentColor).toUpperCase().replace(/\s/g, ''); // Handle non-string values too
               const matchingButton = Array.from(list.querySelectorAll('.settings-color-button')).find(button => {
                   const buttonColor = button.dataset.color;
                   // Also normalize the data-color attribute for comparison
                   return buttonColor && buttonColor.toUpperCase().replace(/\s/g, '') === normalizedCurrentColor;
               });

              if (matchingButton) {
                matchingButton.classList.add('active');
                 // console.log(`updateSettingsUIFromLoadedSettings: Set active color button for ${settingKey} to "${currentColor}"`);
              } else {
                   // This might happen if a color is saved that isn't one of the predefined buttons
                   console.warn(`Current setting color "${currentColor}" (${normalizedCurrentColor}) for ${settingKey} does not match any predefined button.`);
              }
            } else {
                 console.warn(`Current setting color for ${settingKey} is undefined or null.`);
            }
          });
          // console.log("Settings UI updated."); // Debug update complete
        }


    </script>

</body>
</html>